<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skriveflyt</title>
    <style>
/* =========================================================
   SKRIVEHJELP ‚Äì CLEAN GLOBAL CSS (replaces all previous CSS)
   ========================================================= */

/* ---------- Design tokens ---------- */
:root{
  --bg: #f5f7fa;
  --card: #ffffff;
  --text: #111827;
  --muted: #6b7280;
  --border: #e5e7eb;

  --brand: #00b4d8;
  --brand2: #0077b6;
  --brandDark: #005f8d;

  --danger: #e74c3c;
  --dangerDark: #c0392b;

  --r6: 6px;
  --r8: 8px;
  --r10: 10px;
  --r12: 12px;
  --r14: 14px;

  --shadow: 0 2px 10px rgba(0,0,0,.05);
  --shadow2: 0 12px 40px rgba(0,0,0,.25);

  --focus: 0 0 0 2px rgba(0,180,216,.22);
}

/* ---------- Reset / base ---------- */
*{ box-sizing: border-box; }

html, body{
  height: 100%;
}

body{
  margin:0;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: var(--bg);
  color: var(--text);
}

img{ max-width: 100%; display:block; }

a{ color: var(--brand2); text-decoration:none; }
a:hover{ text-decoration:underline; }

/* ---------- Layout ---------- */
.desktop-container{
  display:grid;
  grid-template-columns: 300px 1fr;
  gap:20px;
  padding:20px;
  max-width: 1400px;
  margin: 0 auto;
}

@media (max-width: 768px){
  .desktop-container{ grid-template-columns: 1fr; }
}

.sidebar, .main-content{
  background: var(--card);
  border-radius: var(--r12);
  box-shadow: var(--shadow);
}

.sidebar{
  padding: 20px;
  height: fit-content;
}

.main-content{
  padding: 25px;
}

/* ---------- Header ---------- */
.header{
  background: linear-gradient(90deg, var(--brand2), var(--brand));
  color:#fff;
  padding: 25px;
  border-radius: var(--r12) var(--r12) 0 0;
  margin-bottom: 20px;
  box-shadow: 0 4px 12px rgba(0,0,0,.1);
}

.header h1{
  margin:0;
  font-size: 28px;
}

/* ---------- Titles / sections ---------- */
.section-title{
  font-size: 18px;
  font-weight: 600;
  color: var(--brand2);
  margin: 0 0 15px 0;
  padding-bottom: 8px;
  border-bottom: 2px solid #e6f2ff;
}

.input-group{ margin-bottom: 20px; }

/* ---------- Form controls ---------- */
label{
  display:block;
  margin-bottom: 8px;
  font-weight: 500;
  color:#333;
  font-size: 14px;
}

select,
input[type="text"],
input[type="password"],
textarea{
  width: 100%;
  border: 1px solid #ddd;
  border-radius: var(--r8);
  padding: 10px 12px;
  font-size: 14px;
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
}

textarea{
  height: 200px;
  resize: vertical;
  font-size: 15px;
}

select:focus,
input:focus,
textarea:focus{
  outline: none;
  border-color: var(--brand);
  box-shadow: var(--focus);
  background: #fff;
}

::placeholder{ color: #9ca3af; }

/* ---------- Buttons (one truth) ---------- */
button{
  border: 0;
  border-radius: var(--r10);
  padding: 10px 12px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  color: #fff;
  background: linear-gradient(90deg, var(--brandDark), #0096c7);
  box-shadow: 0 2px 4px rgba(0,0,0,.1);
  transition: transform .15s ease, box-shadow .15s ease, filter .15s ease, opacity .15s ease;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

button:hover{
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,.15);
}

button:active{ transform: translateY(0); }
button:disabled{
  opacity: .6;
  cursor: not-allowed;
  transform:none;
  box-shadow:none;
}

/* Variant buttons */
button.secondary{
  background: #e5e7eb;
  color: #111827;
  box-shadow: none;
}
button.secondary:hover{ filter: brightness(.98); }

button.danger{
  background: var(--danger);
}
button.danger:hover{ filter: brightness(.95); }

.full-width-btn{
  width: 100%;
  padding: 14px 20px;
  font-size: 15px;
}

/* Button groups */
.button-group,
.main-buttons,
.diktat-buttons{
  display:flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-bottom: 15px;
}

.main-buttons button{
  flex: 1;
  min-width: 180px;
}

.diktat-buttons button{
  flex: 1;
  min-width: 120px;
}

/* Primary ‚ÄúSend‚Äù feel (if you have #sendKnapp) */
#sendKnapp{
  background: linear-gradient(90deg, var(--brandDark), var(--brand));
  box-shadow: 0 4px 12px rgba(0,180,216,.3);
}
#sendKnapp:hover{
  box-shadow: 0 6px 16px rgba(0,180,216,.4);
}

/* Loading spinner on buttons */
.loading{ position: relative; }
.loading::after{
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  border: 3px solid rgba(255,255,255,.35);
  border-top-color: #fff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
@keyframes spin{
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

/* ---------- Status / error / result ---------- */
.status{
  margin-top: 10px;
  font-style: italic;
  color: var(--muted);
  font-size: 13px;
}

.error{
  color: var(--danger);
  display:none;
  padding: 10px;
  background: #fdecea;
  border-radius: var(--r6);
  border-left: 3px solid var(--danger);
}

.result{
  margin-top: 25px;
  padding: 20px;
  background: linear-gradient(135deg, #f4fbf9 0%, #edf7fb 100%);
  border-radius: var(--r10);
  display:none;
  box-shadow: 0 4px 12px rgba(0,0,0,.08);
  border-left: 4px solid var(--brand);
}

#resultatTekst{
  white-space: pre-wrap; /* important for "Lagre som mal" */
}

/* ---------- Info boxes (collapsible) ---------- */
.info-box{
  background: #f0f8ff;
  border-radius: var(--r8);
  margin-bottom: 15px;
  font-size: 13px;
  border-left: 3px solid var(--brand2);
}

.info-content{
  padding: 12px;
  max-height: 40px;
  overflow: hidden;
  transition: max-height .25s ease;
}

.info-content.expanded{
  max-height: none;
}

.toggle-button{
  display:block;
  width:100%;
  padding: 6px 12px;
  border-top: 1px solid rgba(0,119,182,.2);
  border-radius: 0 0 var(--r8) var(--r8);
  background: rgba(0,119,182,.05);
  color: var(--brand2);
  font-size: 12px;
  text-decoration: underline;
  box-shadow: none;
  transform:none;
}
.toggle-button:hover{
  color: var(--brandDark);
  text-decoration: none;
}

/* ---------- OCR / file input ---------- */
.file-input-container{
  margin-top: 11px;
}

.file-input-label{
  display:block;
  margin-bottom: 8px;
  font-weight: 600;
  color: #374151;
  font-size: 13px;
}

.file-input-wrapper{
  border: 2px dashed var(--brand);
  border-radius: var(--r8);
  padding: 15px;
  text-align: center;
  cursor: pointer;
  transition: background .2s ease, border-color .2s ease;
  background: #f8f9fa;
}

.file-input-wrapper:hover{
  background: #e9f7fe;
  border-color: var(--brand2);
}

.file-input-wrapper.dragover{
  background: #d4edff;
  border-color: var(--brandDark);
}

.image-preview{
  max-width: 200px;
  max-height: 200px;
  margin-top: 10px;
  border-radius: var(--r8);
  display: none;
}

/* ---------- Database section (raw views) ---------- */
.database-section{
  margin-top: 20px;
  padding: 15px;
  border: 1px solid #eaecef;
  border-radius: var(--r10);
  background: #fafafa;
}

.database-section h3{
  margin: 0 0 10px 0;
  font-size: 16px;
  color: var(--brand2);
}

.database-section pre{
  margin: 0;
  padding: 12px;
  border-radius: var(--r8);
  background: #111827;
  color: #e5e7eb;
  overflow: auto;
  max-height: 360px;
  font-size: 12px;
  line-height: 1.35;
}

/* ---------- VAD tuning panel (if present) ---------- */
/* ---------- VAD / finetuning panel ‚Äì lettere uttrykk ---------- */
#vadTuning{
  margin-top: 10px;
  margin-bottom: 14px;          /* üëà luft ned mot knappene */
  padding: 8px 10px;            /* üëà litt mindre padding */
  border: 1px solid #e5e7eb;    /* üëà tynnere / lysere ramme */
  border-radius: var(--r6);     /* üëà litt mindre radius */
  background: #fcfcfd;          /* üëà nesten hvit, mindre ‚Äúboks‚Äù */
}

#vadTuning .row{
  display:flex;
  gap: 8px;                     /* litt tettere inni panelet */
  align-items:center;
  justify-content: space-between;
  flex-wrap: wrap;
}


#btnVadCalibrate,
#btnVadReset{
  flex: 1 1 120px;   /* üëà N√òKKELEN */
  max-width: 160px; /* valgfritt */
  padding: 6px 10px;
  font-size: 13px;
  line-height: 1.2;
  white-space: nowrap;
  border-radius: var(--r6);
}


/* ---------- Modal base (used by Template Editor etc.) ---------- */
.modal-overlay{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.55);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  padding: 16px;
}

.modal-content{
  width: 100%;
  max-width: 980px;
  background: #fff;
  border-radius: var(--r12);
  padding: 14px;
  box-shadow: var(--shadow2);
}

.modal-content.template-modal{
  max-width: 980px;
}

.modal-header{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 12px;
  border-bottom: 1px solid #eee;
  padding-bottom: 10px;
  margin-bottom: 10px;
}

.modal-header h3{
  margin: 0;
  font-size: 16px;
}

.modal-close{
  width: 40px;
  height: 40px;
  border-radius: var(--r10);
  border: 1px solid #ddd;
  background: #fafafa;
  font-size: 22px;
  cursor: pointer;
  box-shadow: none;
  color: #111827;
}
.modal-close:hover{ filter: brightness(.98); }

/* ---------- Template Editor (legacy modal/editor) ---------- */
.template-toolbar{
  display:flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items:center;
  margin-bottom: 10px;
}

#tplSearch{
  flex: 1 1 240px;
  padding: 10px 12px;
  border: 1px solid #ddd;
  border-radius: var(--r8);
}

.template-body{
  display: grid;
  grid-template-columns: 320px 1fr;
  gap: 12px;
  min-height: 520px;
}

@media (max-width: 920px){
  .template-body{ grid-template-columns: 1fr; }
}

.template-list{
  border: 1px solid #eee;
  border-radius: var(--r10);
  overflow: hidden;
  background: #fbfbfb;
  min-height: 260px;
}

.template-list .row{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 8px;
  padding: 10px 10px;
  border-bottom: 1px solid #eee;
  cursor: pointer;
  background: #fff;
}

.template-list .row:hover{
  background: #f7fbff;
}

.template-list .row.active{
  background: #e9f7fe;
  border-left: 3px solid var(--brand2);
}
/* === FIX: Malbank-liste (scroll + hover + aktiv markering) === */
.template-list{
  /* behold ramme, men la innholdet scrolle */
  overflow: hidden;
}
.template-list #tplList{
  max-height: 520px;
  overflow-y: auto;
  overflow-x: hidden;
}
.template-list .tpl-item{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 8px;
  padding: 10px 10px;
  border-bottom: 1px solid #eee;
  cursor: pointer;
  background: #fff;
  transition: background .12s ease, transform .08s ease;
}
.template-list .tpl-item:hover{
  background: #f7fbff;
  transform: translateX(2px);
}
.template-list .tpl-item.active{
  background: #e9f7fe;
  border-left: 3px solid var(--brand2);
  padding-left: 7px; /* kompenser for venstrekant */
}
.template-list .tpl-title{
  font-weight: 650;
  font-size: 14px;
}
.template-list .tpl-meta{
  font-size: 11px;
  color: #666;
  white-space: nowrap;
}


.template-editor{
  display:flex;
  flex-direction: column;
  gap: 10px;
}

.template-editor textarea{
  height: 360px;
}

.template-editor-actions{
  display: flex;
  gap: 10px;
  flex-wrap: wrap;      /* viktig p√• smale vinduer */
  align-items: center;
  justify-content: flex-start;
}

.template-editor-actions button{
  flex: 0 0 auto;
}

.template-editor-actions #tplStatus,
.template-editor-actions #satStatus{
  margin-left: auto;     /* beholder status til h√∏yre */
}
.template-status{
  color: var(--muted);
  font-size: 12px;
  margin-top: 6px;
}

/* =========================================================
   PROMPT EDITOR MODAL (pe-*)
   (kept standalone but aligned with global look)
   ========================================================= */

.pe-modal{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.5);
  z-index: 9999;
}

.pe-card{
  width: min(1400px, 96vw);
  height: min(860px, 94vh);
  background: #fff;
  margin: 3vh auto;
  border-radius: var(--r14);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: var(--shadow2);
}

.pe-header{
  padding: 14px 16px;
  border-bottom: 1px solid #eee;
  display:flex;
  align-items:flex-start;
  justify-content: space-between;
  gap: 12px;
}

.pe-title{
  font-size: 20px;
  font-weight: 700;
  margin: 0;
}

.pe-sub{
  font-size: 12px;
  color: var(--muted);
  margin-top: 2px;
}

.pe-x{
  width: 40px;
  height: 40px;
  border-radius: var(--r10);
  border: 1px solid #ddd;
  background: #fafafa;
  font-size: 22px;
  cursor: pointer;
  color: #111827;
  box-shadow:none;
  transform:none;
}

/* === Privacy settings modal: ensure readable text (fix white-on-white) === */
#privacySettingsModal .pe-card,
#privacySettingsModal .pe-card *{
  color: #111;
}

#privacySettingsModal .pe-card button{
  color: #111 !important;
  background: #f3f4f6 !important;
  border: 1px solid #d1d5db !important;
  box-shadow: none !important;
}

#privacySettingsModal .pe-card button.btn-primary,
#privacySettingsModal .pe-card .btn-primary{
  color: #fff !important;
  background: linear-gradient(90deg, var(--brandDark), #0096c7) !important;
  border: 0 !important;
  box-shadow: 0 2px 4px rgba(0,0,0,.12) !important;
}

#privacySettingsModal .pe-card button.btn-danger{
  color: #fff !important;
  background: #b91c1c !important;
  border: 0 !important;
}

#privacySettingsModal select,
#privacySettingsModal option,
#privacySettingsModal input,
#privacySettingsModal textarea{
  color: #111 !important;
  background: #fff !important;
}
.pe-x:hover{ filter: brightness(.98); }

.pe-body{
  flex: 1;
  display: grid;
  grid-template-columns: 360px 1fr;
  gap: 0;
  min-height: 0;
}

@media (max-width: 980px){
  .pe-body{ grid-template-columns: 1fr; }
}

.pe-left{
  border-right: 1px solid #eee;
  padding: 12px;
  display:flex;
  flex-direction: column;
  gap: 10px;
  min-height: 0;
}

.pe-search{
  width: 100%;
  padding: 10px 12px;
  border-radius: var(--r10);
  border: 1px solid #ddd;
}


.pe-list{
  flex: 1;
  overflow: auto;
  border: 1px solid #eee;
  border-radius: var(--r10);
  background: #fbfbfb;
}

.pe-item{
  padding: 10px 10px;
  border-bottom: 1px solid #eee;
  cursor: pointer;
  background: #fff;
}

/* Prompt-listen: s√∏rg for lesbar tekst */
#promptList .pe-item{
  color: #111 !important;
}

#promptList .pe-item .k{
  color: #111 !important;
}

#promptList .pe-item .s{
  color: #555 !important;
}

/* Hover/aktiv kan fortsatt ha annen bakgrunn */
#promptList .pe-item:hover{
  background: #f4f6f8;
}

#promptList .pe-item.active{
  background: #e9f2ff;
}


.pe-item:hover{ background: #f7fbff; }
.pe-item.active{
  background: #e9f7fe;
  border-left: 3px solid var(--brand2);
}

.pe-item{
  display: block;
  width: 100%;
  box-sizing: border-box;
  text-align: left;

  /* valgfritt, men anbefalt for ‚Äúliste-look‚Äù */
  border: 0;
  background: #fff;
  border-bottom: 1px solid #eee;
}


.pe-right{
  padding: 12px;
  display:flex;
  flex-direction: column;
  gap: 10px;
  min-height: 0;
}

.pe-toolbar{
  display:flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items:center;
}

.pe-toolbar button{
  padding: 8px 10px;
  border-radius: var(--r10);
  font-size: 13px;
}

.pe-form{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

@media (max-width: 980px){
  .pe-form{ grid-template-columns: 1fr; }
}

.pe-form label{
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 6px;
}

.pe-form input{
  width: 100%;
  padding: 10px 12px;
  border-radius: var(--r10);
  border: 1px solid #ddd;
}

.pe-textarea{
  flex: 1;
  min-height: 0;
}

.pe-textarea textarea{
  height: 100%;
  min-height: 260px;
  border-radius: var(--r10);
}

.pe-status{
  font-size: 12px;
  color: var(--muted);
}

/* Small helper class (if present) */
.s{ font-size: 12px; color: var(--muted); }

#btnPTT:active { transform: scale(0.98); }
#btnPTT.ptt-on {
  filter: brightness(.95);
  box-shadow: 0 0 0 2px rgba(0,180,216,.25);
}

.modal-overlay{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.55);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  padding: 16px;
}
.modal-content{
  width: 100%;
  max-width: 980px;
  background: #fff;
  border-radius: 14px;
  padding: 14px;
  box-shadow: 0 12px 40px rgba(0,0,0,.25);
}
.modal-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  border-bottom:1px solid #eee;
  padding-bottom:10px;
  margin-bottom:10px;
}
.modal-close{
  width:40px;
  height:40px;
  border-radius:10px;
  border:1px solid #ddd;
  background:#fafafa;
  font-size:22px;
  cursor:pointer;
}

.spacer{
  height: 12px;   /* juster etter smak */
}
/* Status i malbank: aldri la den sprenge layouten */
#tplStatus, #satStatus{
  display: inline-block;
  max-width: 320px;      /* juster etter smak */
  max-height: 56px;      /* 2‚Äì3 linjer */
  overflow: auto;
  white-space: pre-wrap;
  word-break: break-word;
  padding: 4px 6px;
  border-radius: 8px;
  background: rgba(0,0,0,0.04);
}

.modal-content.template-modal{
  max-height: 90vh;
  display: flex;
  flex-direction: column;
}

.template-body{
  flex: 1;
  min-height: 0;   /* viktig i flex! */
}

.template-editor{
  min-height: 0;   /* viktig hvis du vil at textarea/innhold kan scrolle */
}

/* === MALBANK: korrekt scroll i modal + grid (m√• st√• helt nederst i CSS) === */

/* 1) Gi modalen en faktisk h√∏ydebegrensning og intern layout */
.modal-content.template-modal{
  max-height: calc(100vh - 32px);
  display: flex;
  flex-direction: column;
  overflow: hidden; /* viktig: scrolling skjer inni barn, ikke p√• modal */
}

/* 2) Toolbar + header tar sin plass, resten f√•r ‚Äúresten av h√∏yden‚Äù */
.modal-content.template-modal .template-body{
  flex: 1;
  min-height: 0; /* KRITISK for at overflow i grid-barn skal virke */
}

/* 3) Grid-barn m√• ogs√• f√• lov √• krympe */
.modal-content.template-modal .template-list,
.modal-content.template-modal .template-editor{
  min-height: 0;
}

/* 4) Selve scroll-omr√•det for venstre liste */
.modal-content.template-modal .template-list{
  overflow: auto !important;
  max-height: none !important;  /* fjern 520px-l√•sen */
}

/* 5) (valgfritt) scroll i editor-kolonnen hvis den blir h√∏y */
.modal-content.template-modal .template-editor{
  overflow: auto;
}

.diktat-actions{
  display:flex;
  gap:8px;
  margin-top:8px;
  flex-wrap:wrap;
}

#sendKnapp {
  background: linear-gradient(135deg, #0077cc, #00a3d9);
  color: #fff;
  font-weight: 600;
  box-shadow: 0 6px 14px rgba(0, 120, 200, 0.25);
}

#sendKnapp:hover {
  filter: brightness(1.05);
}
.main-buttons button:not(#sendKnapp) {
  background: #e9eef3;
  color: #123;
}

.main-buttons button:not(#sendKnapp):hover {
  background: #dde6ee;
}
.main-buttons button {
  height: 46px;
  white-space: nowrap;
}

/* ===== Developer-pent polish (safe overrides) ===== */
:root{
  --nf-text: #0f172a;      /* slate-900 */
  --nf-muted: #475569;     /* slate-600 */
  --nf-border: #e2e8f0;    /* slate-200 */
  --nf-bg: #f8fafc;        /* slate-50 */
  --nf-card: #ffffff;
  --nf-primary: #0284c7;   /* sky-600 */
  --nf-primary2: #0ea5e9;  /* sky-500 */
  --nf-radius: 12px;
  --nf-h: 46px;
}

/* Global-ish text tone */
body{
  color: var(--nf-text);
}

/* Headings: less blue, more ‚Äúproduct‚Äù */
h1,h2,h3{
  color: var(--nf-text);
}

/* Cards: subtle border + soft shadow */
.sidebar, .main-content, .info-box, .pe-card, .section, .card {
  background: var(--nf-card);
  border: 1px solid var(--nf-border);
  box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
  border-radius: var(--nf-radius);
}

/* Inputs/selects/buttons uniform height + radius */
button, select, input[type="text"], textarea{
  border-radius: var(--nf-radius);
}

select, input[type="text"], button{
  height: var(--nf-h);
}

/* Button base */
button{
  border: 1px solid var(--nf-border);
  background: #eef2f7; /* calm */
  color: var(--nf-text);
  font-weight: 600;
  transition: transform .06s ease, filter .15s ease, background .15s ease;
}
button:hover{ filter: brightness(1.02); }
button:active{ transform: translateY(1px); }

/* Primary: Send til GPT */
#sendKnapp{
  border: 0;
  background: linear-gradient(135deg, var(--nf-primary), var(--nf-primary2));
  color: #fff;
  box-shadow: 0 6px 16px rgba(2, 132, 199, 0.18);
}
#sendKnapp:hover{ filter: brightness(1.04); }

/* Secondary buttons in the same row */
.main-buttons button:not(#sendKnapp){
  background: #f1f5f9;
}

/* Danger (if you have a clear button id) */
#btnClearText, #slettKnapp, #clearKnapp{
  background: #fff;
  border-color: #fecaca;      /* red-200 */
  color: #b91c1c;             /* red-700 */
}
#btnClearText:hover, #slettKnapp:hover, #clearKnapp:hover{
  background: #fff1f2;        /* rose-50 */
}

/* Button text no wrap */
.main-buttons button, .diktat-buttons button{
  white-space: nowrap;
}

/* Section titles / helper text */
small, .hint, .status-line{
  color: var(--nf-muted);
}

/* Prompt list items (if relevant) */
#promptList .pe-item{
  border: 1px solid var(--nf-border);
  border-radius: var(--nf-radius);
  background: #fff;
  margin-bottom: 8px;
}
#promptList .pe-item:hover{
  background: #f8fafc;
}

/* ===== A) Diktat-knapper: tydeligere roller ===== */

/* Start diktat = solid secondary (rolig bl√•/gr√•) */
#gptDiktatKnapp {
  background: #e6f2fb;
  border: 1px solid #b6d9f2;
  color: #0b3a57;
  font-weight: 700;
}

/* Hold inne = outline (minst ‚Äútyngde‚Äù) */
#btnPTT {
  background: #fff;
  border: 1px solid #cbd5e1;
  color: #0f172a;
  font-weight: 600;
}

/* Stopp = n√∏ytral/gr√• (ikke prim√¶r) */
#gptStoppKnapp {
  background: #f1f5f9;
  border: 1px solid #e2e8f0;
  color: #334155;
  font-weight: 600;
}

/* Hover-states (subtile) */
#gptDiktatKnapp:hover { filter: brightness(1.02); }
#btnPTT:hover { background: #f8fafc; }
#gptStoppKnapp:hover { background: #eaf0f6; }

/* Disabled fortsatt tydelig */
#gptStoppKnapp:disabled,
#gptDiktatKnapp:disabled,
#btnPTT:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* ===== B) Seksjonstitler litt mer ‚Äúclean‚Äù ===== */
h2, .section-title {
  font-weight: 650;
  letter-spacing: -0.01em;
}

h2 {
  color: #0f172a;     /* mindre bl√•, mer slate */
}

/* hvis du har en bl√• linje under overskrifter, demp den */
.section-divider, hr {
  border-color: #e2e8f0;
}

/* ===== C) Statuslinje: mer bevisst, men rolig ===== */
.status-line {
  margin-top: 8px;
  font-size: 13px;
  color: #475569;          /* slate-600 */
  font-style: italic;
}

.status-line::before {
  content: "‚Ä¢ ";
  color: #94a3b8;          /* slate-400 */
}


/* ===== Prompt Editor Polish ===== */

/* Modal backdrop */
.pe-modal{
  background: rgba(15, 23, 42, .45);
}

/* Card container */
.pe-card{
  border-radius: 14px;
  border: 1px solid #e2e8f0;
  box-shadow: 0 18px 60px rgba(15,23,42,.18);
  overflow: hidden;
}

/* Header: litt strammere */
.pe-header{
  background: #fff;
  border-bottom: 1px solid #e2e8f0;
  padding: 14px 16px;
}
.pe-header h2, .pe-header h1{
  margin: 0;
  font-size: 18px;
  font-weight: 750;
  color: #0f172a;
}
.pe-header .sub{
  margin-top: 2px;
  font-size: 12px;
  color: #64748b;
}

/* Layout spacing i body */
.pe-body{
  gap: 14px;
}

/* Venstreside: s√∏k + liste */
.pe-left{
  min-width: 320px;
}
.pe-search{
  width: 100%;
  height: 42px;
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  padding: 0 12px;
  background: #fff;
}

/* List items: alltid full bredde, ‚Äúkort‚Äù som ikke knekker rart */
#promptList .pe-item{
  display: block;
  width: 100%;
  text-align: left;
  border: 1px solid #e2e8f0;
  background: #fff;
  border-radius: 12px;
  padding: 10px 10px;
  margin: 8px 0;
  box-shadow: 0 1px 2px rgba(15,23,42,.04);
  color: #0f172a;
}
#promptList .pe-item:hover{
  background: #f8fafc;
}
#promptList .pe-item.active{
  border-color: #93c5fd;
  background: #eff6ff;
}

/* Typografi i list items */
#promptList .pe-item .k{
  font-weight: 750;
  font-size: 13px;
  line-height: 1.1;
  margin-bottom: 2px;
}
#promptList .pe-item .s{
  font-size: 12px;
  color: #475569;
  line-height: 1.25;

  /* viktig: ikke rare linjebrudd */
  word-break: break-word;
  overflow-wrap: anywhere;
}

/* H√∏yreside felter: litt mer ‚Äúform‚Äù */
.pe-right label{
  font-size: 12px;
  color: #334155;
  font-weight: 650;
}
.pe-right input[type="text"],
.pe-right input[type="number"],
.pe-right textarea{
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  padding: 10px 12px;
  font-size: 14px;
}

/* Prompt-tekstomr√•de: mer lesbar (ikke ‚Äúkode‚Äù) */
#pe_prompt{
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  line-height: 1.35;
  font-size: 14px;
}

/* Checkbox-linje */
.pe-right .inline-row{
  margin-top: 6px;
  color: #334155;
  font-size: 13px;
}

/* Footer med placeholders: gi luft og ramme */
.pe-footer-note{
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid #e2e8f0;
  font-size: 12px;
  color: #64748b;
}

/* Knappelinje nederst: mindre ‚Äúkaos‚Äù */
.pe-actions{
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items: center;
}

/* Standard action buttons */
.pe-actions button{
  height: 42px;
  border-radius: 12px;
  border: 1px solid #e2e8f0;
  background: #f1f5f9;
  color: #0f172a;
  font-weight: 700;
}
.pe-actions button:hover{ background:#eaf0f6; }

/* Factory reset: ikke r√∏d ‚Äúfare‚Äù, men tydelig advarsel */
#btnFactoryPrompts{
  background: #fff7ed;         /* orange-50 */
  border-color: #fed7aa;       /* orange-200 */
  color: #9a3412;              /* orange-800 */
}
#btnFactoryPrompts:hover{
  background: #ffedd5;
}


/* FIX: s√∏rg for at tekst alltid ligger inni kortet */
.pe-item{
  padding: 12px 14px !important;
  margin: 8px 0 !important;
  height: auto !important;
  box-sizing: border-box !important;
  overflow: hidden !important;  /* hindrer ‚Äústikk ut‚Äù visuelt */
}

/* n√∏kkel: line-height + blokk */
.pe-item .k,
.pe-item .s{
  display: block !important;
  white-space: normal !important;
}

.pe-item .k{
  line-height: 1.25 !important;
  margin: 0 0 2px 0 !important;
}

.pe-item .s{
  line-height: 1.35 !important;
  margin: 0 !important;
}


/* ============================
   MALBANK (template-modal) polish
   ============================ */

/* Modal: litt mer ‚Äúapp‚Äù */
.modal-content.template-modal{
  border-radius: 16px;
  padding: 14px;
  background: #fff;
}

/* Header: strammere */
.modal-content.template-modal .modal-header{
  margin-bottom: 12px;
  padding-bottom: 12px;
}
.modal-content.template-modal .modal-header h3{
  font-size: 20px;
  font-weight: 750;
}

/* Toolbar (s√∏k + knapper) */
.modal-content.template-modal .template-toolbar{
  display:flex;
  gap: 10px;
  align-items:center;
  flex-wrap: nowrap;
  margin-bottom: 12px;
}
.modal-content.template-modal #tplSearch{
  flex: 1 1 auto;
  height: 42px;
  border-radius: 12px;
  border: 1px solid #e2e8f0;
  background: #fff;
}

/* Toolbar-knapper: mindre ‚Äúklump‚Äù */
.modal-content.template-modal .template-toolbar button{
  height: 42px;
  border-radius: 12px;
  padding: 0 12px;
  border: 1px solid #e2e8f0;
  background: #f1f5f9;
  color: #0f172a;
  box-shadow: 0 1px 2px rgba(15,23,42,.06);
}
.modal-content.template-modal .template-toolbar button:hover{
  background: #eaf0f6;
}

/* Grid: bedre proporsjoner */
.modal-content.template-modal .template-body{
  gap: 14px;
  grid-template-columns: 360px 1fr;
}

/* Venstre panel */
.modal-content.template-modal .template-list{
  border: 1px solid #e2e8f0;
  border-radius: 14px;
  background: #fbfdff;
  overflow: hidden;
}

/* Scrollomr√•de */
.modal-content.template-modal .template-list #tplList{
  max-height: none;
  height: calc(94vh - 220px); /* robust nok til store skjermer */
  overflow-y: auto;
  overflow-x: hidden;
  padding: 6px;
}

/* Liste-item */
.modal-content.template-modal .template-list .tpl-item{
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  padding: 10px 10px;
  margin: 8px 0;
  background: #fff;
  transition: background .12s ease, border-color .12s ease, transform .08s ease;
}
.modal-content.template-modal .template-list .tpl-item:hover{
  background: #f8fafc;
  transform: translateX(1px);
}
.modal-content.template-modal .template-list .tpl-item.active{
  background: #eff6ff;
  border-color: #93c5fd;
  box-shadow: 0 1px 2px rgba(2,132,199,.10);
}

/* Tittel + meta */
.modal-content.template-modal .template-list .tpl-title{
  font-weight: 750;
  font-size: 13px;
  color: #0f172a;
  margin-bottom: 2px;
}
.modal-content.template-modal .template-list .tpl-meta{
  font-size: 12px;
  color: #64748b;
  white-space: nowrap;
}

/* H√∏yre panel */
.modal-content.template-modal .template-editor{
  border: 1px solid #e2e8f0;
  border-radius: 14px;
  padding: 12px;
  background: #fff;
  min-height: 0;
}

/* Inputs i editor: konsistent */
.modal-content.template-modal .template-editor input[type="text"],
.modal-content.template-modal .template-editor textarea{
  border: 1px solid #e2e8f0;
  border-radius: 12px;
}

/* Tekstomr√•de: fyll h√∏yden (viktig for ‚Äúapp feel‚Äù) */
.modal-content.template-modal .template-editor textarea{
  min-height: 320px;
  height: calc(94vh - 360px);
  resize: none;
  line-height: 1.35;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}

/* Action-bar nederst: sticky */
.modal-content.template-modal .template-editor-actions{
  position: sticky;
  bottom: 0;
  padding-top: 10px;
  margin-top: 10px;
  background: linear-gradient(to top, #fff 70%, rgba(255,255,255,0));
}

/* Lagre/Slett: tydeligere */
.modal-content.template-modal .template-editor-actions button{
  height: 44px;
  border-radius: 12px;
  padding: 0 14px;
}

/* ===== Malbank: knapper ‚Äì fiks tekst/justering ===== */
.modal-content.template-modal .template-toolbar button,
.modal-content.template-modal .template-editor-actions button{
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 8px !important;

  white-space: nowrap !important;     /* hindrer "+ Ny mal" i √• bryte */
  line-height: 1 !important;          /* hindrer rar vertikal justering */
  padding: 0 14px !important;         /* jevn venstre/h√∏yre */
}

/* Hvis du vil at "+ Ny mal" alltid skal v√¶re √©n linje (mest robust) */
#btnNewTemplate, #btnNewTpl, #btnNyMal, #btnNewMal{
  min-width: 96px !important;
}

/* ===== OCR: Hent tekst fra bilde = samme stil som Start diktat ===== */
#ocrKnapp{
  background: #e6f2fb !important;
  border: 1px solid #b6d9f2 !important;
  color: #0b3a57 !important;
  font-weight: 700 !important;
  box-shadow: 0 2px 6px rgba(11, 58, 87, 0.08) !important;
}

#ocrKnapp:hover{
  filter: brightness(1.03);
}

#ocrKnapp:disabled{
  opacity: 0.6;
  cursor: not-allowed;
}

.app-header{
  margin-bottom: 20px;
}

.app-header h1{
  margin: 0;
  font-size: 26px;
  font-weight: 800;
  letter-spacing: -0.02em;
  color: #0f172a;
}

.app-header .subtitle{
  margin-top: 4px;
  font-size: 14px;
  color: #475569;
}

/* ===== Appbar (full bredde) ===== */
.appbar{
  position: sticky;
  top: 0;
  z-index: 50;
  background: rgba(255,255,255,0.9);
  backdrop-filter: blur(8px);
  border-bottom: 1px solid #e2e8f0;
}

.appbar-inner{
  max-width: 1400px;
  margin: 0 auto;
  padding: 14px 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.brand-title{
  font-size: 20px;
  font-weight: 800;
  letter-spacing: -0.02em;
  color: #0f172a;
  line-height: 1.1;
}

.brand-sub{
  margin-top: 2px;
  font-size: 12px;
  font-weight: 600;
  color: #64748b;
}

/* gi litt luft mellom appbar og innhold */
.desktop-container{
  padding-top: 16px;
}

.appbar{
  background: #ffffff;
  border-bottom: 1px solid #e2e8f0;
}

.appbar-inner{
  padding: 20px 24px;   /* ‚¨Ö mer luft */
}

.brand-title{
  font-size: 22px;      /* ‚¨Ö litt st√∏rre */
  font-weight: 800;
}

.brand-sub{
  font-size: 13px;
  margin-top: 4px;
}

.appbar{
  background: #ffffff;
  border-bottom: 1px solid #e2e8f0;
}

.appbar-inner{
  max-width: 1400px;
  margin: 0 auto;
  padding: 20px 24px;
}

.appbar h1{
  margin: 0;
  font-size: 22px;
  font-weight: 800;
}

.appbar .subtitle{
  margin-top: 4px;
  font-size: 13px;
  color: #475569;
}

.appbar{
  position: sticky;
  top: 0;
  z-index: 50;
  background: #fff;
  border-bottom: 1px solid #e2e8f0;
}

.appbar-inner{
  max-width: 1400px;
  margin: 0 auto;
  padding: 18px 24px;
}

.app-title{
  font-size: 26px;
  font-weight: 800;
  color: #0f172a;
  line-height: 1.1;
}

.app-subtitle{
  margin-top: 4px;
  font-size: 13px;
  color: #475569;
}

.appbar-inner{
  max-width: 1400px;
  margin: 0 auto;
  padding: 18px 20px; /* samme ‚Äúside-luft‚Äù som container */
}

.appbar{
  background: #ffffff;
  border-bottom: 1px solid #e2e8f0;
  box-shadow: 0 1px 0 rgba(15,23,42,.04);
}

.app-title{ letter-spacing: -0.02em; }
.app-subtitle{ color:#64748b; }

.appbar{
  background: linear-gradient(
    180deg,
    #ffffff 0%,
    #f8fafc 100%
  );
  border-bottom: 1px solid #e2e8f0;
}

.result h2{
  font-size: 17px;
  font-weight: 650;
  margin-bottom: 8px;
}

    
/* ===== Soft-gate auth UI ===== */
.auth-bar{
  display:flex; gap:10px; align-items:center; justify-content:flex-end;
  padding:10px 12px; border-bottom:1px solid #eee;
  background:#fff; position:sticky; top:0; z-index:50;
}
.auth-pill{
  font-size:12px; padding:6px 10px; border-radius:999px;
  border:1px solid #e5e5e5; background:#fafafa;
}
.auth-pill.ok{ background:#f0fff4; border-color:#bfe6c7; }
.auth-pill.no{ background:#fff7ed; border-color:#f6d6b8; }

.auth-btn{
  appearance:none; border:1px solid #ddd; background:#fff;
  padding:8px 10px; border-radius:10px; cursor:pointer;
  font-weight:600;
}
.auth-btn:hover{ background:#f7f7f7; }

.auth-modal{
  position:fixed; inset:0; background:rgba(0,0,0,.5);
  display:none; align-items:center; justify-content:center;
  z-index:9999;
}
.auth-modal.open{ display:flex; }
.auth-card{
  width:min(520px, 94vw);
  background:#fff; border-radius:14px;
  box-shadow: 0 10px 30px rgba(0,0,0,.2);
  overflow:hidden;
}
.auth-card header{
  padding:14px 16px; border-bottom:1px solid #eee;
  display:flex; align-items:center; justify-content:space-between;
}
.auth-card header h3{ margin:0; font-size:16px; }
.auth-close{
  border:none; background:transparent; cursor:pointer;
  font-size:20px; line-height:1; padding:6px 8px;
}
.auth-body{ padding:14px 16px; }
.auth-row{ display:flex; gap:10px; align-items:center; margin-top:10px; }
.auth-input{
  flex:1; padding:10px 12px; border-radius:10px;
  border:1px solid #ddd; font-size:14px;
}
.auth-primary{
  padding:10px 12px; border-radius:10px;
  border:1px solid #111; background:#111; color:#fff;
  cursor:pointer; font-weight:700;
}
.auth-primary:disabled{ opacity:.6; cursor:not-allowed; }

.auth-secondary{
  padding:10px 12px; border-radius:10px;
  border:1px solid #ddd; background:#fff; color:#111;
  cursor:pointer; font-weight:600;
}
.auth-secondary:disabled{ opacity:.6; cursor:not-allowed; }

.auth-link{
  padding:10px 12px; border-radius:10px;
  border:1px solid transparent; background:transparent; color:#111;
  cursor:pointer; text-decoration:underline;
}
.auth-link:disabled{ opacity:.6; cursor:not-allowed; }

.auth-danger{
  margin-top:8px;
  padding:10px 12px; border-radius:10px;
  border:1px solid #c53030; background:#fff; color:#c53030;
  cursor:pointer; font-weight:700;
}
.auth-danger:disabled{ opacity:.6; cursor:not-allowed; }

.auth-muted{ font-size:12px; color:#666; margin-top:10px; line-height:1.4; }
.auth-msg{ margin-top:10px; font-size:13px; }



/* ===== Skriveflyt: tabs for Realtime vs Fullfil ===== */
.nf-tabbar{
  display:flex;
  gap: 10px;
  align-items:center;
  margin: 8px 0 6px;
}
.nf-tabspacer{flex:1;}
.nf-tab{
  border: 1px solid var(--nf-border);
  background: #fff;
  border-radius: 999px;
  padding: 4px 10px;
  cursor: pointer;
  font-weight: 600;
}
.nf-tab.active{
  background: #111827;
  color: #fff;
  border-color: #111827;
}
.nf-inline-check{
  display:flex;
  align-items:center;
  gap: 8px;
  padding: 8px 10px;
  border: 1px solid var(--nf-border);
  border-radius: 999px;
  background: #fff;
  user-select: none;
}
.nf-inline-check input{ accent-color: #111827; }
.nf-tabhint{
  margin-top: 6px;
  font-size: 12px;
  color: var(--nf-muted);
}
/* =========================================================
   KONTROLLER OVER TEKSTFELT (kompakt, lik h√∏yde)
   ========================================================= */

.nf-tabbar{
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Faner, Kj√∏r fullfil, Fullfil-tilvalg = samme pille */
.nf-tabbar .nf-tab,
#btnRunFullfile,
.nf-tabbar .nf-inline-check{
  height: 32px;
  padding: 0 10px;
  font-size: 13px;
  line-height: 1;
  display: inline-flex;
  align-items: center;
}

/* Optisk justering for checkbox */
.nf-tabbar .nf-inline-check input[type="checkbox"]{
  transform: scale(0.9);
  margin: 0;
}
/* Fullfil-tilvalg: ikke bruk gap, bruk kontrollert margin p√• checkbox */
.nf-tabbar .nf-inline-check{
  gap: 0 !important;
}

.nf-tabbar .nf-inline-check input[type="checkbox"]{
  margin: 0 6px 0 0 !important;  /* √∏nsket avstand til teksten */
}







</style>
</head>
<body>


<!-- ===== Login modal ===== -->
<div id="authModal" class="auth-modal" aria-hidden="true">
  <div class="auth-card" role="dialog" aria-modal="true" aria-label="Innlogging">
    <header>
      <h3>Logg inn</h3>
      <button class="auth-close" id="authClose" type="button" title="Lukk">√ó</button>
    </header>
    <div class="auth-body">
      <div>Logg inn med e-post og passord. Du kan ogs√• opprette en konto, eller sende lenke for √• sette nytt passord.</div>

      <div class="auth-row" style="margin-top:10px;">
        <input id="authEmail" class="auth-input" type="email" placeholder="din.epost@‚Ä¶" autocomplete="email">
      </div>

      <div class="auth-row">
        <input id="authPassword" class="auth-input" type="password" placeholder="Passord" autocomplete="current-password">
      </div>

      <div class="auth-row" style="gap:8px; flex-wrap:wrap;">
        <button id="authLogin" class="auth-primary" type="button">Logg inn</button>
        <button id="authSignup" class="auth-secondary" type="button">Opprett konto</button>
        <button id="authForgot" class="auth-link" type="button">Glemt passord</button>
      </div>

      <div id="authMsg" class="auth-msg"></div>

      <div id="authDangerZone" style="display:none; margin-top:12px; padding-top:12px; border-top:1px solid #eee;">
        <div class="auth-muted" style="margin-top:0;">‚ö†Ô∏è Fare-sone</div>
        <button id="authDelete" class="auth-danger" type="button">Slett min konto</button>
        <div class="auth-muted" style="margin-top:8px;">Dette kan ikke angres. Pro-tilgang og data knyttet til kontoen blir slettet.</div>
      </div>

      <!-- Recovery / set new password -->
      <div id="authRecovery" style="display:none; margin-top:10px;">
        <div class="auth-muted">Sett nytt passord:</div>
        <div class="auth-row">
          <input id="authNewPassword" class="auth-input" type="password" placeholder="Nytt passord" autocomplete="new-password">
        </div>
        <div class="auth-row">
          <input id="authNewPassword2" class="auth-input" type="password" placeholder="Gjenta nytt passord" autocomplete="new-password">
        </div>
        <div class="auth-row">
          <button id="authSetNewPassword" class="auth-primary" type="button">Oppdater passord</button>
        </div>
      </div>

      <div class="auth-muted" style="margin-top:10px;">
        N√•r du kj√∏per Pro, knyttes betalingen til kontoen din slik at Pro f√∏lger deg p√• tvers av enheter.
      </div>
    </div>
  </div>
</div>
</div>

    <!-- Legg til Tesseract.js bibliotek - nyeste versjon -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<header class="appbar">
  <div class="appbar-inner">

    <div class="appbar-left">
      <div class="app-title">Skriveflyt</div>
      <div class="app-subtitle">diktering, maler og skrivehjelp</div>
    </div>

    <!-- INNLOGGING flyttet inn i app-bar -->
    <div class="auth-bar auth-bar--in-appbar">
      <div id="authPill" class="auth-pill no">üîì Demo (ikke innlogget)</div>
      <button id="btnLogin" class="auth-btn" type="button">Logg inn</button>
      <button id="btnUpgrade" class="auth-btn" type="button" style="display:none;">Oppgrader</button>
      <button id="btnLogout" class="auth-btn" type="button" style="display:none;">Logg ut</button>
    </div>

  </div>
</header>







 <!-- Hovedinnhold (diktat) -->
<div class="desktop-container">
  <div class="sidebar">
   


          
          
         <div class="spacer"></div>

            
            <div class="input-group">
                <label for="modell">Modell:</label>
                <select id="modell">
                    <option value="gpt-5.2" selected>gpt-5.2 (anbefalt)</option>
                    <option value="gpt-5">gpt-5</option>
                    <option value="gpt-5-mini">gpt-5-mini (raskere/billigere)</option>
                    <option value="gpt-5-nano">gpt-5-nano (raskest/billigst)</option>
                    <option value="gpt-4.1">gpt-4.1</option>
                    <option value="gpt-4.1-mini">gpt-4.1-mini</option>
                </select>
                
            </div>
            
            <div class="input-group">
                <label for="promptType">Prompt-type (Ctrl+1 til Ctrl+9):</label>
             <select id="promptType">
  <option value="" disabled selected>Laster prompt-maler‚Ä¶</option>
</select>
<div id="templateSelectionStatus" class="template-status"></div>
            </div>
            
            <div class="input-group">
                <label for="stikkord">Stikkord (for oversettelse til annet spr√•k):</label>
                <input type="text" id="stikkord" placeholder="Skriv spr√•k her (f.eks. tysk, fransk)">
            </div>
 
<button type="button"
        id="btnHelpModal"
        class="secondary full-width-btn">
  üìö Brukerveiledning
</button>

 <div class="spacer"></div>

<div class="info-box" id="personvernInfoBox">
  <div class="info-content collapsible ">
   <strong>üîí Personvern og ansvar</strong><br><br>

Verkt√∏yet er et st√∏tteverkt√∏y for tekstbehandling og er ikke et arkiv- eller saksbehandlingssystem.<br>
Diktering skjer via serverbasert tale-til-tekst.<br>
Tekst som sendes til GPT behandles p√• leverand√∏rens servere.<br><br>

<strong>Brukeren er selv ansvarlig for korrekt bruk av verkt√∏yet.<br>
Ikke legg inn sensitive personopplysninger eller annet konfidensielt innhold.</strong>

    </span>
  </div>

  <button class="toggle-button" onclick="toggleInfoBox('personvernInfoBox')">Vis mer</button>
</div>
        </div>


        <div class="main-content">
<div class="app-header">
  
  
</div>

            
        <div class="input-group">
            <div class="nf-tabbar" role="tablist" aria-label="Transkripsjonsvisning">
  <button type="button" class="nf-tab active" id="tabRealtime" data-tab="rt" aria-selected="true">Realtime</button>
  <button type="button" class="nf-tab" id="tabFullfile" data-tab="full" aria-selected="false">Fullfil</button>
  <div class="nf-tabspacer"></div>
 <button type="button" id="btnRunFullfile" class="secondary" disabled title="Tilvalg: send hele opptaket til /api/transcribe og f√• √©n samlet transkripsjon.">Kj√∏r fullfil</button>
                <label class="nf-inline-check" title="Tilvalg: kj√∏r ogs√• √©n full transkripsjon av hele diktatet n√•r du stopper.">
  <input type="checkbox" id="fullFileToggle">
  Fullfil
</label>
</div>
<textarea id="diktatTekst" placeholder="Dikter eller skriv din tekst. Send til GPT for korrigering eller annen oppgave. Velg oppgave i sidepanelet. Trykk p√• Start diktat for lengre opptak, bruk üéôÔ∏è Hold inne for korte fraser. "></textarea>
<div class="nf-tabhint" id="fullfileHint" style="display:none;">
  Fullfil-transkripsjon genereres n√•r du stopper diktat (hvis tilvalget er p√•).
</div>

        <div class="input-group">
            
           
<div class="diktat-buttons button-group">

<button
  onclick="startGPT4oDiktat_guarded()"
  id="gptDiktatKnapp"
  title="Start kontinuerlig opptak og transkribering (Ctrl + Space). Best for lengre diktat.">
  Start diktat 
</button>




  <button
    type="button"
    id="btnPTT"
    class="secondary"
    title="Push-to-talk: Hold inne for opptak, slipp for √• sende til transkribering (Ctrl + P). Best for korte fraser.">
    üéôÔ∏è Hold inne
  </button>

  <button
    onclick="stoppGPT4oDiktat()"
    id="gptStoppKnapp"
    disabled
    title="Stopp p√•g√•ende opptak (Ctrl + B)">
    Stopp 
  </button>

  <button
    onclick="slettDiktatTekst()"
    id="slettKnapp"
    title="Slett all tekst i diktatfeltet (Ctrl + S)">
    Slett tekst
  </button>

  <button
    onclick="anonymiserTekst()"
    id="anonymiserKnapp"
    title="Anonymiser tekst lokalt f√∏r videre bruk (Ctrl + A)">
    Anonymiser üîí
  </button>

  <button
    type="button"
    onclick="openPrivacySettingsModal()"
    id="privacySettingsKnapp"
    title="Anonymisering ‚Äì innstillinger">
    ‚öôÔ∏èüîí‚öôÔ∏è
  </button>

  <button
    onclick="angreAnonymisering()"
    id="angreAnonymiseringKnapp"
    title="Angre siste anonymisering (Ctrl + Z)"
    style="display:none;">
    üîÑ
  </button>

</div>


<!-- Egen rad under hovedknappene -->
<div class="diktat-actions">

  <button
    onclick="angreAnonymisering()"
    id="angreAnonymiseringKnapp"
    title="Angre siste anonymisering (Ctrl + Z)"
    style="display: none;">
    Angre anonymisering üîÑ
  </button>

</div>

<div class="status-line" id="diktatStatus">Klar for opptak og transkribering.</div>


        <div class="input-group">
            <div class="main-buttons">
                <button onclick="sendTilGPT_guarded()" id="sendKnapp" title="Send til GPT">Send til GPT</button>
                <button onclick="kopierTilUtklippstavle()" id="kopierKnapp" title="Ctrl + K">Kopier til utklippstavle </button>
                <button onclick="flyttResultatTilDiktat()" id="flyttKnapp" title="Ctrl + F">Flytt resultat til diktat </button>
            </div>
            <div class="error" id="feilMelding">Noe gikk galt. Vennligst sjekk OpenAI API-n√∏kkelen din og pr√∏v igjen.</div>
        </div>
        
        <div class="result" id="result">
            <h2>Resultat fra GPT:</h2>
            <p id="resultatTekst"></p>
            <div class="button-group" style="margin-top: 15px;">
                <button onclick="openSaveAsTemplateModal()" id="lagreSomMalKnapp">üíæ Lagre som mal</button>
            </div>
        </div>

        
        <!-- OCR-seksjon flyttet nederst for √• ikke v√¶re i veien -->
        <div class="ocr-section" style="margin-top: 30px;">
            <div class="section-title">OCR - Hent tekst fra bilde</div>
            
      
            
            <div class="file-input-container">
                <div class="file-input-label">Last opp bilde for tekstgjenkjenning:</div>
                <div class="file-input-wrapper" id="fileDropArea">
                    <p>Dra og slipp, klikk for √• velge, knapp under for utklippstavle</p>
                    <p style="font-size: 11px; color: #666; margin-top: 2px;">St√∏ttede formater: JPG, PNG, GIF</p>
                    <input type="file" id="fileInput" accept="image/*">
                </div>
                <img id="imagePreview" class="image-preview" alt="Bildeforh√•ndsvisning">
                <div class="button-group" style="margin-top: 10px;">
                    <button onclick="startOCR()" id="ocrKnapp">Hent tekst fra bilde</button>
                    <button onclick="slettBilde()" id="slettBildeKnapp" disabled>Fjern bilde</button>
                    <button onclick="limInnFraUtklippstavle()" id="limInnKnapp">Lim inn bilde fra utklippstavle</button>
                </div>
                <div class="status" id="ocrStatus">Klar for bildeopplasting...</div>
            </div>
        </div>
        
      <!-- Informasjonsboks om personvern -->
            <div style="background-color: #e8f4fd; padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 13px; border-left: 3px solid #00b4d8;">
                <strong>üîí Personvernsinformasjon:</strong>
                <ul style="margin: 8px 0 0 20px; padding: 0;">
                    <li style="margin-bottom: 4px;"> <strong>OCR-prosessering skjer lokalt</strong> - Bilde og tekst forlater aldri din maskin</li>
                    <li style="margin-bottom: 4px;"> <strong>Ingen opplasting</strong> - Alt skjer i nettleseren din</li>
                    <li style="margin-bottom: 4px;"> <strong>GPT-korrektur sender tekst til sky</strong> - N√•r du sender til GPT, prosesseres teksten p√• deres servere</li>
                    <li style="margin-bottom: 4px;"> <strong>Du kan bruke OCR uten GPT</strong> - Teksten legges i diktatfeltet for manuell redigering</li>
                </ul>
            </div>

        <div class="database-section"> 
    <div class="section-title">Personaliser</div>
    <div class="button-group">
        <button onclick="openTemplateEditor()" id="visMalbankKnapp">üìÅ Malbank</button>

        <!-- NY: √•pner prompt-editor -->
        <button id="btnOpenPromptEditor" type="button">üìÅ Prompter</button>
    </div>

    <div class="status" id="databaseStatus" style="margin-top: 10px;">Lokal mal-database klar</div>

    <!-- Databasevisning flyttet nederst i hovedfeltet -->
    <div id="databaseVisning" style="display: none; margin-top: 20px; padding: 15px; background: white; border-radius: 8px; max-height: 400px; overflow-y: auto; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
        <h3>Mal-database innhold:</h3>
        <pre id="databaseInnhold" style="white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 14px;"></pre>
        <button onclick="lukkDatabaseVisning()" style="margin-top: 10px; padding: 8px 16px;">Lukk</button>
    </div>

    <!-- =========================================================
         NYTT: Prompt Editor Modal (legg CSS i &lt;style&gt; og JS i &lt;script&gt;)
         ========================================================= -->
    <div id="promptEditorModal" class="pe-modal" style="display:none;">
        <div class="pe-card">
            <div class="pe-header">
                <div>
                    <div class="pe-title">Prompter</div>
                    <div class="pe-sub">Endringene lagres til <code>prompt_maler.json</code></div>
                </div>
                <button id="btnClosePromptEditor" type="button" class="pe-x">‚úï</button>
            </div>

            <div class="pe-body">
                <div class="pe-left">
                    <div class="pe-toolbar">
                        <button id="btnNewPrompt" type="button">Ny</button>
                        <button id="btnDuplicatePrompt" type="button">Dupliser</button>
                        <button id="btnDeletePrompt" type="button">Slett</button>
                    </div>

                    <input id="promptSearch" type="text" placeholder="S√∏k id/type..." class="pe-search" />

                    <div id="promptList" class="pe-list"></div>
                </div>

                <div class="pe-right">
                    <label class="pe-label">ID (m√• v√¶re unik)</label>
                    <input id="pe_id" type="text" class="pe-input" />
<label class="pe-label">Hotkey (Ctrl+1‚Äì9) Skriv kun tall fra 1-9. Overtar hurtigtasten hvis annet prompt har hurtigtasten fra f√∏r</label>
<input id="pe_hotkey" type="number" min="1" max="9" step="1" class="pe-input" placeholder="1‚Äì9 (valgfritt)" />


                    <label class="pe-label">Type (Angir navn som sees i listen)</label>
                    <input id="pe_type" type="text" class="pe-input" />

                    <label class="pe-label">Beskrivelse</label>
                    <input id="pe_beskrivelse" type="text" class="pe-input" />
<label style="font-size:13px;">
  <input type="checkbox" id="pe_useMalDatabase">
  Send relevante maler fra database
</label>

                    <label class="pe-label">Prompt</label>
                    <textarea id="pe_prompt" rows="14" class="pe-textarea"></textarea>

                    <div class="pe-actions">
                        <button id="btnSavePrompts" type="button">Lagre til JSON</button>
                        <button id="btnReloadPrompts" type="button">Last p√• nytt</button>
                        <button id="btnExportPrompts" type="button">Eksporter JSON</button>
                        <button id="btnImportPrompts" type="button">Importer JSON</button>
<button id="btnFactoryPrompts" type="button" class="danger">Gjenopprett fabrikk-prompter</button>
                        <input id="promptImportFile" type="file" accept="application/json" style="display:none;" />

                        <span id="pe_status" class="pe-status"></span>
                    </div>

                    <div class="pe-hint">
                        St√∏ttede placeholders: Angir input; Diktatets tekstfelt, stikkordsfelt for spr√•k og maldatabase:
                        <code>[TEKST_INNHOLD]</code>,
                        <code>[SPR√ÖK]</code>,
                        <code>[MAL_DATABASE]</code>,
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</div>

            <div id="vadTuning" style="margin-top:12px; padding:10px; border:1px solid #ddd; border-radius:8px;">
  <div id="vadTuningHeader"
       style="display:flex; align-items:center; justify-content:space-between; gap:10px; cursor:pointer;">
    <strong>‚öôÔ∏è Mikrofon-tuning</strong>
    <span id="vadTuningChevron" style="user-select:none;">‚ñ∏</span>
  </div>

  <div id="vadTuningBody" style="margin-top:10px; display:none;">

    <div style="margin-top:10px;">
      <div style="display:flex; align-items:center; gap:10px;">
        <span style="width:140px;">RMS-niv√•</span>
        <div style="flex:1; height:10px; background:#eee; border-radius:999px; overflow:hidden;">
          <div id="rmsBar" style="height:100%; width:0%; background:#888;"></div>
        </div>
        <span id="rmsVal" style="width:70px; text-align:right; font-variant-numeric: tabular-nums;">0.000</span>
      </div>
      <div style="margin-top:4px; font-size:12px; color:#666;">
        Tips: Still inn s√• ‚Äústille‚Äù ligger lavt, og tale gir tydelig h√∏yere RMS.
      </div>
    </div>

    <div style="margin-top:12px; display:grid; grid-template-columns: 140px 1fr 80px; gap:8px 10px; align-items:center;">
      <label for="slStart">Start terskel</label>
      <input type="range" id="slStart" min="0.005" max="0.080" step="0.001">
      <span id="vStart"></span>

      <label for="slStop">Stopp terskel</label>
      <input type="range" id="slStop" min="0.003" max="0.070" step="0.001">
      <span id="vStop"></span>

      <label for="slSilence">Pause f√∏r klipp (ms)</label>
      <input type="range" id="slSilence" min="200" max="2000" step="50">
      <span id="vSilence"></span>

      <label for="slMinPhrase">Min frase (ms)</label>
      <input type="range" id="slMinPhrase" min="300" max="2000" step="50">
      <span id="vMinPhrase"></span>

      <label for="slMaxPhrase">Max frase (ms)</label>
      <input type="range" id="slMaxPhrase" min="4000" max="20000" step="500">
      <span id="vMaxPhrase"></span>

      <button type="button" id="btnVadCalibrate">Auto-kalibrer</button>
      <button type="button" id="btnVadReset">Reset</button>
    </div>

  </div>
</div>
        


  <div id="calibStatus" style="margin-top:10px; font-size:12px; color:#444;"></div>
</div>

<script>
        // Test om JavaScript lastes
        console.log('JavaScript lastet - siden fungerer!');
        
     
        
        // Variabler for OCR-funksjonalitet
        let selectedFile = null;
        let isProcessingOCR = false;

// Rate limit for "Send til GPT"
const REQUEST_DELAY = 3000; // ms (juster som du vil)
let lastRequestTime = 0;

        
        // Lagre originaltekst for angre-funksjonalitet
        let originalTextBeforeAnonymization = null;
        
     // ================================
// Hurtigtaster (Ctrl + ...)
// - Ctrl+Space: Start diktat
// - Ctrl+B:     Stopp diktat
// - Ctrl+Enter: Send til GPT
// - Ctrl+S:     Slett diktattekst
// - Ctrl+F:     Flytt resultat -> diktat
// - Ctrl+K:     Kopier til utklippstavle
// - Ctrl+A:     Anonymiser
// - Ctrl+Z:     Angre anonymisering
// - Ctrl+P:     Push-to-talk (hold inne)
// NB: Ctrl+1..9 h√•ndteres annet sted (hotkeyMap/JSON)
// ================================
(function setupHotkeys() {
  const functionShortcuts = {
   " ": "startGPT4oDiktat_guarded",  // Ctrl + Space
    "b": "stoppGPT4oDiktat",          // Ctrl + B
"Enter": "sendTilGPT_guarded",    // Ctrl + Enter
    "s": "slettDiktatTekst",          // Ctrl + S
    "f": "flyttResultatTilDiktat",    // Ctrl + F
    "k": "kopierTilUtklippstavle",    // Ctrl + K
    "a": "anonymiserTekst",           // Ctrl + A
    "z": "angreAnonymisering"         // Ctrl + Z
  };

  function isTypingContext(target) {
    if (!target) return false;
    const tag = (target.tagName || "").toUpperCase();
    return tag === "INPUT" || tag === "TEXTAREA" || target.isContentEditable;
  }

  // --- Ctrl+P push-to-talk (hold inne)
  let pttHotkeyDown = false;

  document.addEventListener("keydown", (event) => {
    if (!event.ctrlKey) return;

    // Ctrl+1..9 styres av hotkeyMap/JSON et annet sted
    if (event.key >= "1" && event.key <= "9") return;

    // Ctrl+P h√•ndteres separat (hold inne)
    if ((event.key || "").toLowerCase() === "p") return;

    // Normaliser tast
    let key = event.key;
    if (key && key.length === 1) key = key.toLowerCase();

    const fnName = functionShortcuts[key];
    if (!fnName) return;

    // Unng√• rot mens man skriver? (valgfritt)
    // For disse hurtigtastene er det ofte greit √• tillate ogs√• n√•r man st√•r i textarea,
    // men du kan stramme inn ved √• sl√• p√• denne:
    // if (isTypingContext(event.target) && key !== "Enter") return;

    event.preventDefault();

    const fn = window[fnName];
    if (typeof fn === "function") {
      try { fn(); } catch (e) { console.error("Hurtigtast-feil:", e); }
    }
  });

  // Ctrl+P: start PTT p√• keydown, stopp p√• keyup
document.addEventListener("keydown", (event) => {
  if (!event.ctrlKey) return;
  if ((event.key || "").toLowerCase() !== "p") return;
  if (event.repeat) return;

  event.preventDefault(); // stopper "Print"
  pttHotkeyDown = true;

  const btn = document.getElementById("btnPTT");
  try { btn && btn.dispatchEvent(new Event("pointerdown")); } catch (e) {}
});

document.addEventListener("keyup", (event) => {
  if ((event.key || "").toLowerCase() !== "p") return;
  if (!pttHotkeyDown) return;

  event.preventDefault();
  pttHotkeyDown = false;

  const btn = document.getElementById("btnPTT");
  try { btn && btn.dispatchEvent(new Event("pointerup")); } catch (e) {}
});


// Sikkerhet: hvis vinduet mister fokus mens Ctrl+P holdes
window.addEventListener("blur", () => {
  if (!pttHotkeyDown) return;
  pttHotkeyDown = false;
  const btn = document.getElementById("btnPTT");
  try { btn && btn.dispatchEvent(new Event("pointerup")); } catch (e) {}
});
})();


        
   
        
        // Initialiser kollapsbare bokser
        document.addEventListener('DOMContentLoaded', function() {
            // S√∏rg for at alle kollapsbare bokser starter kollapset
            const collapsibleBoxes = document.querySelectorAll('.info-box.collapsible');
            collapsibleBoxes.forEach(box => {
                box.classList.remove('expanded');
            });
            
            // Skjul utvidet innhold for brukerveiledning ved oppstart
            const expandedContents = document.querySelectorAll('.expanded-content');
            expandedContents.forEach(content => {
                content.style.display = 'none';
            });
        });

                
     

// Henter prompt-maler via server (√©n sann kilde)
async function hentPromptMaler() {
  // Hent prompt-maler fra LocalStorage, men s√∏rg for at DEFAULT_PROMPT_MALER alltid finnes.
  const seedDefaults = () => {
    const payload = {
      schemaVersion: PROMPT_DB_SCHEMA_VERSION,
      updatedAt: new Date().toISOString(),
      promptMaler: Array.isArray(DEFAULT_PROMPT_MALER) ? DEFAULT_PROMPT_MALER : []
    };
    localStorage.setItem(PROMPT_DB_KEY, JSON.stringify(payload));
    return payload.promptMaler;
  };

  const save = (maler) => {
    const payload = {
      schemaVersion: PROMPT_DB_SCHEMA_VERSION,
      updatedAt: new Date().toISOString(),
      promptMaler: maler
    };
    localStorage.setItem(PROMPT_DB_KEY, JSON.stringify(payload));
  };

  const raw = localStorage.getItem(PROMPT_DB_KEY);
  if (!raw) return seedDefaults();

  try {
    const obj = JSON.parse(raw);

    // St√∏tt b√•de {schemaVersion,promptMaler:[...]} og direkte array-lagring.
    const ver = obj?.schemaVersion;
    if (ver && ver !== PROMPT_DB_SCHEMA_VERSION) {
      console.warn(`Feil schemaVersion i LocalStorage: ${ver} (forventer ${PROMPT_DB_SCHEMA_VERSION}). Seeder defaults.`);
      return seedDefaults();
    }

    let maler = [];
    if (obj && Array.isArray(obj.promptMaler)) maler = obj.promptMaler;
    else if (Array.isArray(obj)) maler = obj;
    else maler = [];

    // Hvis tomt ‚Üí seed defaults
    if (!Array.isArray(maler) || maler.length === 0) return seedDefaults();

    // S√∏rg for at alle default-propter finnes (uten √• overskrive brukerens endringer)
    const eksisterende = new Set(maler.map(m => String(m?.id || "").trim()).filter(Boolean));
    const mangler = (Array.isArray(DEFAULT_PROMPT_MALER) ? DEFAULT_PROMPT_MALER : [])
      .filter(m => m && m.id && !eksisterende.has(String(m.id).trim()));

    if (mangler.length) {
      maler = [...maler, ...mangler];
      save(maler);
    }

    return maler;
  } catch (e) {
    console.warn("Kunne ikke lese prompt-maler fra LocalStorage. Seeder defaults.", e);
    return seedDefaults();
  }
}


let hotkeyMap = {}; // f.eks. { "1": "korrektur", "2": "ocr_korrektur" }

async function byggPromptDropdown({ beholdValg = true, sorter = false } = {}) {
  const select = document.getElementById("promptType");
  if (!select) return;

  const tidligereValg = beholdValg ? select.value : "";

  const maler = await hentPromptMaler();
  if (!Array.isArray(maler)) throw new Error("Prompt-maler er ikke en liste");

  // (valgfritt) sorter etter type
  const liste = sorter
    ? [...maler].sort((a, b) => (a.type || "").localeCompare(b.type || "", "nb"))
    : [...maler];

  // Reset
  hotkeyMap = {};
  select.innerHTML = "";

  if (!liste.length) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.disabled = true;
    opt.selected = true;
    opt.textContent = "Ingen prompt-maler ‚Äì √•pne Prompt-editoren for √• lage/importere";
    select.appendChild(opt);
    return;
  }

 // Bygg options
for (const m of liste) {
  if (!m.id) continue;

  const opt = document.createElement("option");
  opt.value = m.id;

  const hotkeyStr = (m.hotkey !== undefined && m.hotkey !== null && String(m.hotkey).trim() !== "")
    ? String(m.hotkey).trim()
    : "";

  opt.textContent = (m.type || m.id) + (hotkeyStr ? ` (Ctrl+${hotkeyStr})` : "");
  select.appendChild(opt);

  // Bygg hotkeyMap
  if (hotkeyStr) {
    hotkeyMap[hotkeyStr] = m.id;
  }
}


  // Sett valg tilbake hvis mulig
  if (tidligereValg && [...select.options].some(o => o.value === tidligereValg)) {
    select.value = tidligereValg;
  } else if (select.options.length) {
    select.selectedIndex = 0;
  }

  // Valider hotkeys (valgfritt men nyttig)
  validerHotkeysFraMap(hotkeyMap);
}

function validerHotkeysFraMap(map) {
  // map har unike keys, men vi kan sjekke at de er 1..9 og at id finnes
  for (const [hk, id] of Object.entries(map)) {
    if (!(hk >= "1" && hk <= "9")) {
      console.warn(`Hotkey "${hk}" er utenfor 1-9 (id="${id}")`);
    }
  }
}

function velgPromptVedId(id) {
  const select = document.getElementById("promptType");
  if (!select) return false;

  const finnes = [...select.options].some(o => o.value === id);
  if (!finnes) return false;

  select.value = id;

  // Om du har logikk p√• change, trig den:
  select.dispatchEvent(new Event("change", { bubbles: true }));
  return true;
}



        
        // M√∏nstre for anonymisering (personidentifiserbar informasjon)
        
        // ================================
        // Anonymisering (mild / hybrid / streng)
        // - lagrer "sist anonymisert" i minnet for visning i modal
        // ================================
        const PRIVACY_SETTINGS_KEY = "privacySettings_v1";
        const LAST_ANONYMIZED_KEY  = "lastAnonymized_v1";

        const defaultPrivacySettings = {
          autoAnonymize: true,
          mode: "hybrid" // mild | hybrid | strict
        };

        function loadPrivacySettings() {
          try {
            const raw = localStorage.getItem(PRIVACY_SETTINGS_KEY);
            if (!raw) return { ...defaultPrivacySettings };
            const obj = JSON.parse(raw);
            return { ...defaultPrivacySettings, ...(obj || {}) };
          } catch (_) {
            return { ...defaultPrivacySettings };
          }
        }

        function savePrivacySettings(s) {
          try { localStorage.setItem(PRIVACY_SETTINGS_KEY, JSON.stringify(s || defaultPrivacySettings)); } catch (_) {}
        }

        function loadLastAnonymized() {
          try {
            const raw = localStorage.getItem(LAST_ANONYMIZED_KEY);
            if (!raw) return { items: [], stats: {} };
            const obj = JSON.parse(raw);
            return obj && typeof obj === "object" ? obj : { items: [], stats: {} };
          } catch (_) {
            return { items: [], stats: {} };
          }
        }

        function saveLastAnonymized(payload) {
          try { localStorage.setItem(LAST_ANONYMIZED_KEY, JSON.stringify(payload || { items: [], stats: {} })); } catch (_) {}
        }

        // Stoppliste som reduserer falske positive ved navn (verb/vanlige ord i setninger)
        const NAME_STOPWORDS = new Set([
          "bekrefter","beskrives","inntraff","opplever","oppgir","√∏nsker","arbeider","bor","sier","viser","kontrollert",
          "hjemme","s√∏ndag","kveld","datert","tidligere","telefon","e-postadresse",
          "arbeidsgiver","kontakt","avdelingen","utstedt","statens","vegvesen","regnr","iban","ip",
          "og","deres","to","barn"
        ]);

        // Kjerne-regler (faste m√∏nstre) ‚Äì alltid trygge √• maskere
        const CORE_RULES = [
          { type:"EPOST",  re:/\b[\w.+-]+@[\w.-]+\.[A-Za-z]{2,}\b/g, repl:"[EPOST]" },

          // Telefon: norsk/intl +47 912 34 567 / 56 32 11 00 / 0047...
          { type:"TELEFON", re:/\b(?:\+|00)?\s?\d{1,3}[\s-]?(?:\d[\s-]?){7,14}\b/g, repl:"[TELEFON]" },

          // F√∏dselsnummer (11) og ddmmyy-xxxxx / ddmmyyxxxxx
          { type:"FNR", re:/\b\d{6}[- ]?\d{5}\b/g, repl:"[FNR]" },
          { type:"FNR", re:/\b\d{11}\b/g, repl:"[FNR]" },

          // Dato f√∏dt: 12.03.1984 / 12/03/1984 / 1956 (ved "f." eller "f√∏dt")
          { type:"F√òDT", re:/\b\d{1,2}[./-]\d{1,2}[./-]\d{2,4}\b/g, repl:"[F√òDT]" },
          { type:"F√òDT", re:/\b(?:f\.|f√∏dt)\s*(?:i\s*)?\d{4}\b/gi, repl:"[F√òDT]" },

          // IP
          { type:"IP-ADRESSE", re:/\b(?:\d{1,3}\.){3}\d{1,3}\b/g, repl:"[IP-ADRESSE]" },

          // Regnr (bil): AB12345
          { type:"REGNR", re:/\b[A-Z√Ü√ò√Ö]{2}\d{5}\b/g, repl:"[REGNR]" },

          // Orgnr 9 siffer (ofte prefiks orgnr/org.nr/arbeidsgiver)
          { type:"ORGNUMMER", re:/\b(?:org\.?nr\.?|orgnr|organisasjonsnummer)\s*[:.]?\s*\d{9}\b/gi, repl:"[ORGNUMMER]" },
          { type:"ORGNUMMER", re:/\b\d{9}\b/g, repl:"[ORGNUMMER]" },

          // Konto/IBAN
          { type:"KONTO", re:/\b\d{4}\.\d{2}\.\d{5}\b/g, repl:"[KONTO]" },               // norsk kontonr med punktum
          { type:"KONTO", re:/\bNO\d{13}\b/gi, repl:"[KONTO]" },                         // norsk IBAN uten mellomrom (typisk)
          { type:"KONTO", re:/\b(?:iban)\s*[:.]?\s*[A-Z]{2}\d{2}[A-Z0-9]{11,30}\b/gi, repl:"[KONTO]" },

          // ID (f√∏rerkort/pnr/pass etc) ‚Äì enkle alfanum. kjeder med prefiks "nr."
          { type:"ID-NR", re:/\b(?:f√∏rerkort|pass|id)\s*(?:nr\.?|no\.?|#)?\s*[A-Z0-9]{6,12}\b/gi, repl:"[ID-NR]" },

          // Poststed: 0567 Oslo (krever stor O i Oslo for √• unng√• "2024 beskrives")
          { type:"POSTSTED", re:/\b\d{4}\s+[A-Z√Ü√ò√Ö][a-z√¶√∏√•]{2,}(?:\s+[A-Z√Ü√ò√Ö][a-z√¶√∏√•]{2,})*\b/g, repl:"[POSTSTED]" },
        ];

        // Navn-regler (justeres etter modus)
        function applyNameRules(input, mode, outItems) {
          let txt = input;

          // 1) Initialer: K. A. Hansen / Kari A H
          const initRe = /\b(?:[A-Z√Ü√ò√Ö]\.\s*){1,3}[A-Z√Ü√ò√Ö][a-z√¶√∏√•]{2,}\b/g;
          txt = txt.replace(initRe, (m) => { outItems.push({type:"INITIALET_NAVN", value:m}); return "[INITIALET_NAVN]"; });

          const spacedInitRe = /\b[A-Z√Ü√ò√Ö][a-z√¶√∏√•]{2,}\s+(?:[A-Z√Ü√ò√Ö]\s+){1,3}\b/g;
          txt = txt.replace(spacedInitRe, (m) => { outItems.push({type:"INITIALET_NAVN", value:m}); return "[INITIALET_NAVN]"; });

          // 2) Fullt navn: Kari Anne Hansen / Anne-Lise Berg / Per O. Nilsen
          const fullNameRe = /\b[A-Z√Ü√ò√Ö][a-z√¶√∏√•]{1,}(?:[-][A-Z√Ü√ò√Ö][a-z√¶√∏√•]{1,})?(?:\s+(?:[A-Z√Ü√ò√Ö]\.|[A-Z√Ü√ò√Ö][a-z√¶√∏√•]{1,}(?:[-][A-Z√Ü√ò√Ö][a-z√¶√∏√•]{1,})?)){1,3}\b/g;
          txt = txt.replace(fullNameRe, (m) => {
            // Filter i hybrid/mild: ikke mask√©r hvis match inneholder stoppord
            const parts = m.split(/\s+/).map(s => s.replace(/[^\p{L}.‚Äô-]/gu,"")).filter(Boolean);
            const lowered = parts.map(p => p.replace(/\./g,"").toLowerCase());
            const hasStop = lowered.some(w => NAME_STOPWORDS.has(w));
            if ((mode === "hybrid" || mode === "mild") && hasStop) return m;
            outItems.push({type:"NAVN", value:m});
            return "[NAVN]";
          });

          // 3) Kontekst-baserte sm√•bokstav-navn (f.eks. "ektefellen ole hansen")
          if (mode === "hybrid" || mode === "strict") {
            const ctxRe = /\b(ektefellen|ektemann|mor|far|nav-kontakt|kontakt)\s+([a-z√¶√∏√•]{2,}(?:\s+[a-z√¶√∏√•]{2,}){0,2})\b/gi;
            txt = txt.replace(ctxRe, (m, p1, namePart) => {
              const lowered = String(namePart).toLowerCase().split(/\s+/);
              if (lowered.some(w => NAME_STOPWORDS.has(w))) return m;
              outItems.push({type:"NAVN", value:namePart});
              return `${p1} [NAVN]`;
            });
          }

          // 4) Barn-liste: "Emil (8 √•r) og Ida (5 √•r)" ‚Äì mask√©r fornavn n√•r det etterf√∏lges av "(<tall> √•r)"
          if (mode === "hybrid" || mode === "strict") {
            const childRe = /\b([A-Z√Ü√ò√Ö][a-z√¶√∏√•]{1,})\s*\(\s*\d{1,2}\s*√•r\s*\)/g;
            txt = txt.replace(childRe, (m, name) => {
              outItems.push({type:"NAVN", value:name});
              return `[NAVN] (${m.match(/\(\s*\d{1,2}\s*√•r\s*\)/)?.[0] || ""}`.trim();
            });
          }

          return txt;
        }

        // Adresse-regler
        function applyAddressRules(input, mode, outItems) {
          let txt = input;

          // Norsk gate + husnr: Storgata 14B / Sandviksveien 22
          const noStreetRe = /\b([A-Z√Ü√ò√Ö][a-z√¶√∏√•]+(?:[-\s][A-Z√Ü√ò√Ö]?[a-z√¶√∏√•]+)*?(?:gata|gate|vei|veien|vegen|svingen|bakken|all√©|alle|plassen|slette|tunet|tun|lia|li|voll|v√•g|strand|stien|stien|stien|hagen|toppen|√•sen))\s+(\d{1,4}[A-Za-z√Ü√ò√Ö√¶√∏√•]?)\b/g;
          txt = txt.replace(noStreetRe, (m) => { outItems.push({type:"ADRESSE", value:m}); return "[ADRESSE]"; });

          // Internasjonal adresse: 221B Baker Street, London NW1 6XE (bevarer land/by hvis √∏nskelig)
          const intlStreetRe = /\b\d{1,4}[A-Za-z]?\s+[A-Z][A-Za-z]+(?:\s+[A-Z][A-Za-z]+){0,4}\s+(Street|St|Road|Rd|Avenue|Ave|Lane|Ln|Boulevard|Blvd|Drive|Dr)\b[^\n,]*?/g;
          txt = txt.replace(intlStreetRe, (m) => { outItems.push({type:"ADRESSE", value:m.trim()}); return "[ADRESSE]"; });

          return txt;
        }

        function anonymizeText(text, mode) {
          const outItems = [];
          let t = String(text || "");

          // 1) Kjerne-regler
          for (const rule of CORE_RULES) {
            t = t.replace(rule.re, (m) => { outItems.push({ type: rule.type, value: m }); return rule.repl; });
          }

          // 2) Adresse
          t = applyAddressRules(t, mode, outItems);

          // 3) Navn (varierer etter modus)
          t = applyNameRules(t, mode, outItems);

          // 4) Streng modus: mask√©r enkeltnavn (stor forbokstav) i visse kontekster
          if (mode === "strict") {
            const soloNameRe = /\b[A-Z√Ü√ò√Ö][a-z√¶√∏√•]{2,}\b/g;
            t = t.replace(soloNameRe, (m) => {
              const w = m.toLowerCase();
              if (NAME_STOPWORDS.has(w)) return m;
              // unng√• √• maskere starten av setninger som "Brukeren" osv.
              if (["brukeren","kunden","mor","far","dr","hr","regnr","ip"].includes(w)) return m;
              outItems.push({type:"NAVN", value:m});
              return "[NAVN]";
            });
          }

          // Stats
          const stats = outItems.reduce((acc, it) => (acc[it.type]=(acc[it.type]||0)+1, acc), {});
          return { text: t, items: outItems, stats };
        }

        
        // Funksjon for √• vise/skjule informasjonsbokser
        function toggleInfoBox(boxId) {
            const box = document.getElementById(boxId);
            const content = box.querySelector('.info-content');
            const button = box.querySelector('.toggle-button');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                button.textContent = 'Vis mer';
            } else {
                content.classList.add('expanded');
                button.textContent = 'Vis mindre';
            }
        }

        // Spesialisert funksjon for brukerveiledning med utvidet innhold
        function toggleBrukerveiledning() {
            const box = document.getElementById('brukerveiledningInfoBox');
            const content = box.querySelector('.info-content');
            const expandedContent = box.querySelector('.expanded-content');
            const button = box.querySelector('.toggle-button');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                expandedContent.style.display = 'none';
                button.textContent = 'Vis mer';
            } else {
                content.classList.add('expanded');
                expandedContent.style.display = 'block';
                button.textContent = 'Vis mindre';
            }
        }
        
        // Initialiser kollapsbare bokser
        document.addEventListener('DOMContentLoaded', function() {
            const collapsibleContents = document.querySelectorAll('.info-content');
            collapsibleContents.forEach(content => {
                content.classList.remove('expanded');
            });
        });
        


      
            
            // Vis informasjon om tilgjengelige modeller
            console.log("OpenAI-modeller: gpt-5.x, gpt-4.1, m.fl.");
            console.log("Tilgjengelige modeller varierer etter konto/prosjekt. Bruk knappen for √• hente listen.");
            
            // Sett opp dra-og-slipp for bildeopplasting
            setupFileDropArea();
        
        
    
        
        // Legg til event listener for modellendring
        document.getElementById('modell').addEventListener('change', function() {
            const valgtModell = this.value;
            const modellInfo = document.getElementById('modellInfo');
            modellInfo.textContent = `Valgt modell: ${valgtModell}`;
            modellInfo.style.color = '#00b4d8';
        });
        
        // =====================================================
// GPT-4o DIKTAT (phrase-basert med stillhetsdeteksjon)
// =====================================================
let gptSessionTimer = null;
const GPT_MAX_SESSION_MS = 4 * 60 * 1000; // 4 minutter

let gptRunning = false;
let gptStream = null;

let audioCtx = null;
let analyser = null;
let sourceNode = null;
let rafId = null;

let mediaRecorder = null;
let currentChunks = [];

let isRecording = false;
let silenceMs = 0;
let lastTickTs = 0;

let sending = false;
const sendQueue = [];

let phraseStartTs = 0;
// ===== Pattern A: "interim-klipp" + "final master" =====
let fullRecorder = null;
let fullChunks = [];
let sessionAppendStartIndex = 0; // hvor i tekstfeltet denne diktat-√∏kten startet √• legge til tekst
let finalizing = false;


// --- Anti-st√∏y / anti-"vifte-ord" ---
const MIN_SEND_MS = 1000;   // forkast klipp kortere enn dette (600‚Äì900 er typisk)
let phraseRmsSum = 0;
let phraseRmsCount = 0;
// valgfritt: hvis du vil ha RMS-gulv senere
const MIN_MEAN_RMS = 0.012;


let cutting = false;          // hindrer dobbel-stop
let pendingStartAfterStop = false; // start ny recorder etter at onstop har k√∏et blob


function appendText(t) {
  const ta = document.getElementById("diktatTekst");
  if (!t) return;
  ta.value += (ta.value && !ta.value.endsWith(" ") ? " " : "") + t;
}


function pickMimeOptions() {
  let options = {};
  if (MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) {
    options.mimeType = "audio/webm;codecs=opus";
  } else if (MediaRecorder.isTypeSupported("audio/webm")) {
    options.mimeType = "audio/webm";
  }
  return options;
}

function startFullRecorder() {
  if (!gptStream) return;

  fullChunks = [];
  const options = pickMimeOptions();
  fullRecorder = new MediaRecorder(gptStream, options);

  fullRecorder.ondataavailable = (e) => {
    if (e.data && e.data.size > 0) fullChunks.push(e.data);
  };

  fullRecorder.onerror = (e) => {
    console.error("FullRecorder error:", e);
  };

  // Timeslice gj√∏r at browser ‚Äúflusher‚Äù litt underveis (mindre risiko for rare edge-cases / minne)
  try {
    fullRecorder.start(1000); // 1s chunks
  } catch (e) {
    console.warn("Kunne ikke starte fullRecorder:", e);
    fullRecorder = null;
    fullChunks = [];
  }
}

function stopFullRecorderAndGetBlob() {
  return new Promise((resolve) => {
    if (!fullRecorder) return resolve(null);

    const fr = fullRecorder;

    fr.onstop = () => {
      try {
        const mime = fr.mimeType || "audio/webm";
        const blob = new Blob(fullChunks, { type: mime });
        resolve(blob && blob.size > 2500 ? blob : null);
      } catch (e) {
        console.error("FullRecorder onstop build blob failed:", e);
        resolve(null);
      } finally {
        fullRecorder = null;
        fullChunks = [];
      }
    };

    try {
      if (fr.state !== "inactive") fr.stop();
      else resolve(null);
    } catch (e) {
      resolve(null);
    }
  });
}

// Vent til alle interim-klipp er sendt (pumpSendQueue jobber ferdig)
async function waitForSendQueueDrain() {
  while (sending || sendQueue.length > 0) {
    await new Promise(r => setTimeout(r, 80));
  }
}

// ===== Live interim (Pattern A rolling window) =====
let liveIntervalId = null;
let liveInFlight = false;
let liveLastAppended = ""; // til enkel dedupe
const LIVE_WINDOW_SEC = 14;        // hvor mye lyd vi sender i hvert vindu
const LIVE_SEND_EVERY_MS = 5000;   // roligere p√• cloud (mindre k√∏)   // hvor ofte vi sender et vindu

function computeOverlapAppend(existing, incoming){
  const a = (existing || "").slice(-120).toLowerCase();
  const b = (incoming || "").slice(0,120).toLowerCase();
  let best = 0;
  const max = Math.min(a.length, b.length);
  for (let n = 1; n <= max; n++){
    if (a.slice(-n) === b.slice(0,n)) best = n;
  }
  return incoming.slice(best);
}

let liveDraftText = "";

function renderLiveDraft(draft){
  const ta = document.getElementById("diktatTekst");
  if (!ta) return;

  const before = ta.value.slice(0, sessionAppendStartIndex);
  const base = (before || "");
  const sep = (base && !base.endsWith(" ") && !base.endsWith("\n")) ? " " : "";

  const d = (draft || "").trim();
  if (!d){
    // ingen draft ‚Äì vis bare base
    ta.value = base;
    return;
  }

  // Vis draft som "forel√∏pig" som alltid overskrives (ikke append),
  // for √• unng√• duplisering fra overlappende vinduer.
  ta.value = base + sep + "\n\n‚è≥ Forel√∏pig: " + d;
}

function collapseImmediateRepeats(text){
  // Enkel "anti-dobbelt": fjerner umiddelbare gjentakelser av korte fraser.
  // (Kun for forel√∏pig-visning ‚Äì final transcribe er uendret.)
  if (!text) return text;
  const words = text.split(/\s+/).filter(Boolean);
  if (words.length < 6) return text;

  for (let n = 6; n >= 1; n--){
    let changed = false;
    for (let i = 0; i + 2*n <= words.length; i++){
      let same = true;
      for (let k = 0; k < n; k++){
        if (words[i+k].toLowerCase() !== words[i+n+k].toLowerCase()){
          same = false; break;
        }
      }
      if (same){
        words.splice(i+n, n);
        changed = true;
        i = Math.max(-1, i - n);
      }
    }
    if (changed) break;
  }
  return words.join(" ");
}

function appendLiveText(txt){
  // Forel√∏pig tekst = overskrives hver gang (som WebSpeech "interim")
  let t = (txt || "").trim();
  if (!t){
    liveDraftText = "";
    renderLiveDraft("");
    return;
  }

  // Rydd litt for "dobbelt-ord"/gjentakelser som kan komme av overlapp i vindu
  t = collapseImmediateRepeats(t);

  // Unng√• √• spamme UI hvis nesten identisk
  const prev = liveDraftText || "";
  if (prev && t && prev.length > 20){
    const a = prev.slice(-120).toLowerCase();
    const b = t.slice(-120).toLowerCase();
    if (a === b) return;
  }

  liveDraftText = t;
  renderLiveDraft(liveDraftText);
}



function getRollingBlob(){
  if (!fullChunks || fullChunks.length === 0) return null;
  const mime = (fullRecorder && fullRecorder.mimeType) ? fullRecorder.mimeType : "audio/webm";
  // Bygg fra START for √• f√• gyldig container (header/cues). Dette er mer robust enn √• slice siste chunks.
  const blob = new Blob(fullChunks, { type: mime });
  return blob && blob.size > 4000 ? blob : null;
}


function startLiveInterimLoop(){
  stopLiveInterimLoop(); // sikker
  liveLastAppended = ""; // nullstill per √∏kt
  liveInFlight = false;

  liveIntervalId = setInterval(async () => {
    if (!gptRunning || finalizing) return;
    if (liveInFlight) return;

    const blob = getRollingBlob();
    if (!blob) return;

    liveInFlight = true;
    try {
      const txt = await transcribeAudio(blob);
      // NB: transcribe returnerer "full vindu"-tekst, s√• vi limer p√• med dedupe
      appendLiveText(txt);
    } catch (e) {
      // ignorer midlertidige feil i live
      console.warn("Live transcribe feilet:", e);
    } finally {
      liveInFlight = false;
    }
  }, LIVE_SEND_EVERY_MS);
}

async function stopLiveInterimLoop(){
  if (liveIntervalId){
    clearInterval(liveIntervalId);
    liveIntervalId = null;
  }
  // vent p√• evt p√•g√•ende live-kall
  while (liveInFlight){
    await new Promise(r => setTimeout(r, 80));
  }
}



async function startGPT4oDictationPhrase() {
  if (gptSessionTimer) clearTimeout(gptSessionTimer);

  gptSessionTimer = setTimeout(() => {
    console.warn("GPT-4o diktat stoppet automatisk (timeout)");
    stopGPT4oDictationPhrase(); // <-- FIX: riktig funksjonsnavn
  }, GPT_MAX_SESSION_MS);

  if (gptRunning) return;

  gptRunning = true;
  isRecording = false;
  silenceMs = 0;
  lastTickTs = performance.now();
  phraseStartTs = 0;

  // reset queue
  sendQueue.length = 0;

  // reset cut state
  cutting = false;
  pendingStartAfterStop = false;

  // hvor i tekstfeltet denne √∏kten starter √• legge til tekst
  const ta = document.getElementById("diktatTekst");
  sessionAppendStartIndex = ta ? ta.value.length : 0;
  finalizing = false;

  // Mic
  gptStream = await navigator.mediaDevices.getUserMedia({
    audio: {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true
    }
  });

  // Start "master" opptak for endelig kvalitet
  startFullRecorder();

  // Start live interim (rolling window)
  startLiveInterimLoop();

  // WebAudio analyse
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // VIKTIG: Chrome/Edge kan v√¶re "suspended" uten resume() p√• brukerhandling
  if (audioCtx.state !== "running") {
    try { await audioCtx.resume(); } catch (e) {}
  }

  sourceNode = audioCtx.createMediaStreamSource(gptStream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  sourceNode.connect(analyser);

  // (valgfritt men nyttig for auto-kalibrer)
  window.__vadAnalyser = analyser;
  window.__vadAudioCtx = audioCtx;

  // I Pattern A (live + final) bruker vi ikke pause-klipping (VAD) her.
  // Live-loop sender forel√∏pig tekst, og master-opptaket brukes til endelig kvalitet ved stopp.
  // pumpSendQueue();
  // startRecorder();
  // rafId = requestAnimationFrame(vadTick);
}



async function stopGPT4oDictationPhrase() {
  if (gptSessionTimer) {
    clearTimeout(gptSessionTimer);
    gptSessionTimer = null;
  }

  // Stopp loops slik at vi ikke klipper mer
  gptRunning = false;

  // 1) Stopp klippe-recorder (venter til blob er k√∏et)
  if (mediaRecorder && mediaRecorder.state === "recording") {
    pendingStartAfterStop = false; // ikke start ny recorder ved ekte stopp
    try { await stopRecorderAndQueue(); } catch (_) {}
  }

    // 1.5) Stopp live interim-loop
  try { await stopLiveInterimLoop(); } catch (_) {}

  // 2) Stopp VAD loop
  if (rafId) cancelAnimationFrame(rafId);
  rafId = null;

  // 3) Pause-klipp brukes ikke i Pattern A her, s√• ingen k√∏ √• vente p√•.
  // (Hvis du senere skrur p√• VAD igjen, kan du reaktivere waitForSendQueueDrain.)
  renderLiveDraft(""); // fjern forel√∏pig-linjen f√∏r final

  // 4) Stopp master recorder og transkriber HEL fil
  finalizing = true;
  let finalBlob = null;
  try {
    finalBlob = await stopFullRecorderAndGetBlob();
  } catch (e) {
    console.warn("stopFullRecorderAndGetBlob feilet:", e);
  }

  if (finalBlob) {
    try {
      const finalText = await transcribeAudio(finalBlob);

      if (finalText && finalText.trim()) {
        const ta = document.getElementById("diktatTekst");
        if (ta) {
          const before = ta.value.slice(0, sessionAppendStartIndex);
          const sep = (before && !before.endsWith(" ")) ? " " : "";
          ta.value = before + sep + finalText.trim();
        }
      }
    } catch (e) {
      console.error("Final transcribe failed:", e);
      // hvis final feiler: behold interim-resultatet
    }
  }

  // 5) Rydd WebAudio
  try { if (sourceNode) sourceNode.disconnect(); } catch (e) {}
  sourceNode = null;
  analyser = null;

  if (audioCtx) {
    try { await audioCtx.close(); } catch (e) {}
    audioCtx = null;
  }

  // 6) Stopp mic
  if (gptStream) {
    try { gptStream.getTracks().forEach(t => t.stop()); } catch (e) {}
    gptStream = null;
  }

  finalizing = false;
}


function vadTick(ts) {
  if (!gptRunning || !analyser) return;

  // tid siden sist (i ms) for korrekt stillhetsm√•ling
  const dt = ts - (lastTickTs || ts);
  lastTickTs = ts;

  // Beregn RMS (lydenergi)
  const buf = new Uint8Array(analyser.fftSize);
  analyser.getByteTimeDomainData(buf);

  let sum = 0;
  for (let i = 0; i < buf.length; i++) {
    const v = (buf[i] - 128) / 128;
    sum += v * v;
  }
  const rms = Math.sqrt(sum / buf.length);

  // Oppdater meter
  updateRmsUI(rms);
// --- Samle RMS for gjeldende frase (for st√∏yfiltrering) ---
if (mediaRecorder && mediaRecorder.state === "recording") {
  phraseRmsSum += rms;
  phraseRmsCount += 1;
}


  // hent tuning LIVE (ikke frosne const)
  const stopThr = vadSettings.stopThreshold;
  const silenceHold = vadSettings.silenceHoldMs;
  const minPhrase = vadSettings.minPhraseMs;
  const maxPhrase = vadSettings.maxPhraseMs;

  // Vi spiller inn kontinuerlig, men klipper ved pauser / maks-lengde
  if (mediaRecorder && mediaRecorder.state === "recording") {
    if (rms < stopThr) {
      silenceMs += dt;
    } else {
      silenceMs = 0;
    }

    const phraseMs = ts - phraseStartTs;

    // sikkerhetsklipp ved lang tale uten pause
    if (phraseMs >= maxPhrase) {
      requestCut("maxPhrase");
    } else if (silenceMs >= silenceHold && phraseMs >= minPhrase) {
      // klipp ved pause
      requestCut("silence");
    }
  }

  rafId = requestAnimationFrame(vadTick);
}



function requestCut(reason) {
  if (!gptRunning) return;
  if (cutting) return;
  if (!mediaRecorder) return;
  if (mediaRecorder.state !== "recording") return;

  cutting = true;
  pendingStartAfterStop = true;

  // stopRecorderAndQueue() starter ny recorder i onstop-wrapperen
  stopRecorderAndQueue().catch(() => {}).finally(() => {
    // failsafe: hvis onstop ikke fyrer, start igjen etter kort tid
    setTimeout(() => {
      if (!gptRunning) { cutting = false; pendingStartAfterStop = false; return; }

  if (!mediaRecorder && pendingStartAfterStop) {
  pendingStartAfterStop = false;

  startRecorder();
  phraseStartTs = performance.now();
  phraseRmsSum = 0;
  phraseRmsCount = 0;
  silenceMs = 0;

  cutting = false;
}
    }, 300);
  });
}


/* =====================================================
   Realtime dictation (NO INTERIM / only FINAL segments)
   WS -> Cloud Run -> OpenAI Realtime transcription
   ===================================================== */

let rt_ws = null;
let rt_audioCtx = null;
let rt_processor = null;
let rt_source = null;
let rt_stream = null;
let rt_running = false;

// Auto-stopp (failsafe) for realtime + fullfil-opptak
let nf_rtAutoStopTimer = null;
const NF_RT_MAX_MS = 4 * 60 * 1000; // 4 minutter


// bygg wss://... fra apiUrl("/ws/transcribe_realtime")
function wsUrl(path){
  return apiUrl(path).replace(/^http/i, "ws");
}

// Float32 [-1..1] -> Int16 PCM
function floatTo16BitPCM(float32Array) {
  const out = new Int16Array(float32Array.length);
  for (let i=0;i<float32Array.length;i++){
    let s = Math.max(-1, Math.min(1, float32Array[i]));
    out[i] = s < 0 ? (s * 0x8000) : (s * 0x7FFF);
  }
  return out;
}

// Downsample til 24kHz (WebAudio kj√∏rer ofte 48k)
function downsampleTo24k(buffer, inputSampleRate) {
  const targetRate = 24000;
  if (inputSampleRate === targetRate) return buffer;

  const ratio = inputSampleRate / targetRate;
  const newLength = Math.round(buffer.length / ratio);
  const result = new Float32Array(newLength);

  let offsetResult = 0;
  let offsetBuffer = 0;

  while (offsetResult < result.length) {
    const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
    let sum = 0, count = 0;
    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
      sum += buffer[i];
      count++;
    }
    result[offsetResult] = count ? (sum / count) : 0;
    offsetResult++;
    offsetBuffer = nextOffsetBuffer;
  }
  return result;
}

// base64 encode Int16 PCM
function b64FromInt16(int16) {
  const bytes = new Uint8Array(int16.buffer);
  let bin = "";
  const chunk = 0x8000;
  for (let i=0;i<bytes.length;i+=chunk){
    bin += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
  }
  return btoa(bin);
}

function setDiktatStatus(text){
  const el = document.getElementById("diktatStatus");
  if (el) el.textContent = text || "";
}

function appendFinalToTextarea(text){
  nf_appendRealtimeFinal(text);
}


// Vi forventer OpenAI event-format forwarded fra backend.
// Vi tar kun "completed" og ignorerer alt interim.
function handleRealtimeEvent(obj){
  if (!obj || typeof obj !== "object") return;

  // hvis backend sender egne status/error
  if (obj.type === "status") {
    setDiktatStatus(obj.status || "Realtime");
    return;
  }
  if (obj.type === "error") {
    setDiktatStatus("Realtime-feil: " + (obj.error || obj.message || ""));
    return;
  }

  // OpenAI completed segment
  if (obj.type === "conversation.item.input_audio_transcription.completed") {
    appendFinalToTextarea(obj.transcript || "");
    return;
  }

  // robust fallback: hvis andre completed-typer dukker opp med transcript/text
  const isCompleted = typeof obj.type === "string" && obj.type.includes("completed");
  const maybeText =
    (typeof obj.transcript === "string" && obj.transcript) ||
    (typeof obj.text === "string" && obj.text) ||
    "";

  if (isCompleted && maybeText) {
    appendFinalToTextarea(maybeText);
  }
}

async function startRealtimeDictation(){
  if (rt_running) return;

  // bruker eksisterende getAccessToken() fra softGate-blokka din
  const token = await getAccessToken();
  if (!token) throw new Error("Du er ikke innlogget (mangler access token).");

  setDiktatStatus("Realtime: kobler til‚Ä¶");

  rt_ws = new WebSocket(wsUrl("/ws/transcribe_realtime"));

  await new Promise((resolve, reject) => {
    rt_ws.onopen = resolve;
    rt_ws.onerror = reject;
    setTimeout(() => reject(new Error("WS timeout")), 8000);
  });

  rt_ws.onmessage = (ev) => {
    let obj;
    try { obj = JSON.parse(ev.data); } catch { return; }
    handleRealtimeEvent(obj);
  };
  rt_ws.onerror = () => setDiktatStatus("Realtime: WS-feil");
  rt_ws.onclose = () => {
  rt_ws = null;
  // hvis vi allerede har stoppet, ikke overstyr status
  if (!rt_running) return;
  rt_running = false;
  setDiktatStatus("Realtime: lukket");
};


  // init (token m√• sendes i body siden browser WS ikke sender Authorization header)
  rt_ws.send(JSON.stringify({ type:"init", token, language:"nb", model:"gpt-4o-mini-transcribe" }));

  // mic + WebAudio
  rt_stream = await navigator.mediaDevices.getUserMedia({
    audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false }
  });

  
  // Tilvalg: ta opp √©n hel fil parallelt (transkriberes ved stopp)
  nf_fullEnabled = !!document.getElementById("fullFileToggle")?.checked;
  nf_fullRecorder = null;
  nf_fullChunks = [];

  if (nf_fullEnabled && rt_stream) {
    try {
      nf_fullRecorder = new MediaRecorder(rt_stream);
      nf_fullRecorder.ondataavailable = (e) => { if (e.data && e.data.size) nf_fullChunks.push(e.data); };
      nf_fullRecorder.start();
      nf_setRunButtonEnabled(false);
      nf_fullBlobStored = null;
      const hint = document.getElementById("fullfileHint");
      if (hint) hint.style.display = (nf_activeTab === "full") ? "block" : "none";
    } catch (e) {
      console.warn("Kunne ikke starte fullfil-opptak:", e);
      nf_fullEnabled = false;
      nf_fullRecorder = null;
      nf_fullChunks = [];
    }
  }
rt_audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (rt_audioCtx.state !== "running") {
    try { await rt_audioCtx.resume(); } catch (e) {}
  }

  rt_source = rt_audioCtx.createMediaStreamSource(rt_stream);
  rt_processor = rt_audioCtx.createScriptProcessor(4096, 1, 1);

  rt_processor.onaudioprocess = (e) => {
    if (!rt_ws || rt_ws.readyState !== 1) return;
    const input = e.inputBuffer.getChannelData(0);
    const down = downsampleTo24k(input, rt_audioCtx.sampleRate);
    const pcm16 = floatTo16BitPCM(down);
    rt_ws.send(JSON.stringify({ type:"audio", audio: b64FromInt16(pcm16) }));
  };

  rt_source.connect(rt_processor);
  rt_processor.connect(rt_audioCtx.destination);

  rt_running = true;
  // start/refresh auto-stopp timer
  try { if (nf_rtAutoStopTimer) clearTimeout(nf_rtAutoStopTimer); } catch(e){}
  nf_rtAutoStopTimer = setTimeout(() => {
    // hvis den fortsatt kj√∏rer etter 4 min, stopp alt pent
    stopRealtimeDictation().catch(() => {});
  }, NF_RT_MAX_MS);

  setDiktatStatus("Realtime: lytter‚Ä¶");
}

async function stopRealtimeDictation(){
  if (!rt_running) return;
  // stopp auto-stopp timer
  try { if (nf_rtAutoStopTimer) clearTimeout(nf_rtAutoStopTimer); } catch(e){}
  nf_rtAutoStopTimer = null;


  // flush siste buffer
  try { if (rt_ws && rt_ws.readyState === 1) rt_ws.send(JSON.stringify({type:"control", action:"commit"})); } catch(e){}

  // Hvis fullfil-opptak er aktivt: stopp recorder n√• (f√∏r vi stopper tracks)
  let nf_fullBlob = null;
  if (nf_fullEnabled && nf_fullRecorder && nf_fullRecorder.state !== "inactive") {
    try {
      await new Promise((resolve) => {
        nf_fullRecorder.onstop = resolve;
        nf_fullRecorder.stop();
      });
      const mime = nf_fullRecorder.mimeType || "audio/webm";
      nf_fullBlob = (nf_fullChunks && nf_fullChunks.length) ? new Blob(nf_fullChunks, { type: mime }) : null;
    } catch (e) {
      console.warn("Fullfil-opptak stopp feilet:", e);
    } finally {
      nf_fullRecorder = null;
    }
  }


  // rydd audio
  try { rt_processor && rt_processor.disconnect(); } catch(e){}
  try { rt_source && rt_source.disconnect(); } catch(e){}
  rt_processor = null;
  rt_source = null;

  if (rt_audioCtx) {
    try { await rt_audioCtx.close(); } catch(e){}
    rt_audioCtx = null;
  }

  if (rt_stream) {
    try { rt_stream.getTracks().forEach(t => t.stop()); } catch(e){}
    rt_stream = null;
  }

  // lukk ws
  try { if (rt_ws) rt_ws.close(); } catch(e){}
  rt_ws = null;

  rt_running = false;
  // Hvis vi har full blob: start fullfil-transkripsjon i bakgrunnen
  if (nf_fullBlob && nf_fullBlob.size > 4000) {
    nf_fullBlobStored = nf_fullBlob;
    // Aktiver "Kj√∏r fullfil" hvis vi faktisk har opptak
    try { nf_setRunButtonEnabled(!!(nf_fullBlobStored && nf_fullBlobStored.size > 0)); } catch(e){}

    nf_setRunButtonEnabled(true);
    // Hint: Fullfil-fanen kan n√• kj√∏res via knappen
  }

  // Hvis vi ikke har fullfil-opptak tilgjengelig, hold knappen disabled
  if (!(nf_fullBlobStored && nf_fullBlobStored.size > 0)) {
    try { nf_setRunButtonEnabled(false); } catch(e){}
  }

  setDiktatStatus("Stoppet.");
}


// --- API base: dev -> localhost:5000, prod -> same origin (relative) ---
// --- API base: dev -> localhost:5000, prod -> Cloud Run ---
const API_BASE =
  (location.hostname === "localhost" || location.hostname === "127.0.0.1")
    ? "http://127.0.0.1:5000"
    : "https://skriveflyt-x5ypikri3q-lz.a.run.app";


// Safe join (unng√• dobbel //)
function apiUrl(path) {
  return (API_BASE ? API_BASE.replace(/\/$/, "") : "") + path;
}
    async function apiFetchAuthed(path, options = {}) {
  const { data, error } = await supabaseClient.auth.getSession();
  const token = data?.session?.access_token;

  if (!token) {
    throw new Error("Du er ikke innlogget (mangler access token).");
  }

  const headers = new Headers(options.headers || {});
  headers.set("Authorization", "Bearer " + token);
  // NB: Ikke sett Content-Type n√•r du sender FormData (browser gj√∏r det riktig selv)

  return fetch(apiUrl(path), { ...options, headers });
}

// =========================
// Rate limit UX helpers
// =========================
function nf_getRetryAfterSeconds(res, fallbackSec = 20){
  try{
    const ra = res.headers && res.headers.get("Retry-After");
    const sec = parseInt(String(ra || ""), 10);
    return (Number.isFinite(sec) && sec > 0) ? sec : fallbackSec;
  }catch(e){
    return fallbackSec;
  }
}

function nf_disableButtonForSeconds(btn, seconds, label){
  if(!btn) return;
  const orig = btn.dataset.nfOrigText || btn.textContent;
  btn.dataset.nfOrigText = orig;

  // clear any prior timer
  const prior = btn.dataset.nfCooldownTimer;
  if(prior){
    try{ clearInterval(Number(prior)); }catch(e){}
    delete btn.dataset.nfCooldownTimer;
  }

  btn.disabled = true;
  let remaining = Math.max(1, Math.floor(seconds));
  const base = (label || orig).trim();

  const tick = ()=>{
    if(remaining <= 0){
      btn.disabled = false;
      btn.textContent = orig;
      if(btn.dataset.nfCooldownTimer){
        try{ clearInterval(Number(btn.dataset.nfCooldownTimer)); }catch(e){}
        delete btn.dataset.nfCooldownTimer;
      }
      return;
    }
    btn.textContent = `${base} (${remaining}s)`;
    remaining -= 1;
  };

  tick();
  const t = setInterval(tick, 1000);
  btn.dataset.nfCooldownTimer = String(t);
}

// Shared cooldowns (stops runaway loops)
let nf_transcribeCooldownUntil = 0; // epoch ms
let nf_responsesCooldownUntil = 0;  // epoch ms

function nf_inCooldown(untilMs){
  return Date.now() < (untilMs || 0);
}


async function transcribeAudio(blob) {
  // Global cooldown if we recently hit rate limit
  if (nf_inCooldown(nf_transcribeCooldownUntil)) {
    const sec = Math.ceil((nf_transcribeCooldownUntil - Date.now()) / 1000);
    const b = document.getElementById("btnRunFullfile");
    nf_disableButtonForSeconds(b, sec, "Vent litt");
    throw new Error(`For mange transkripsjoner. Pr√∏v igjen om ${sec}s.`);
  }
  const fd = new FormData();
  fd.append("audio", blob, "audio.webm");
  fd.append("language", "nb");

 const res = await apiFetchAuthed("/api/transcribe", {
  method: "POST",
  body: fd
});


  if (!res.ok) {
    if (res.status === 429) {
      const sec = nf_getRetryAfterSeconds(res, 20);
      nf_transcribeCooldownUntil = Date.now() + sec * 1000;
      const b = document.getElementById("btnRunFullfile");
      nf_disableButtonForSeconds(b, sec, "Vent litt");
      throw new Error(`For mange transkripsjoner. Pr√∏v igjen om ${sec}s.`);
    }
    const t = await res.text().catch(() => "");
    throw new Error(`Transcribe HTTP ${res.status}: ${t}`);
  }

  const data = await res.json();
  return data?.text ? String(data.text) : "";
}

function startRecorder() {
  if (!gptStream) return;

  currentChunks = [];
  isRecording = true;

  let options = {};
  if (MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) {
    options.mimeType = "audio/webm;codecs=opus";
  } else if (MediaRecorder.isTypeSupported("audio/webm")) {
    options.mimeType = "audio/webm";
  }

  mediaRecorder = new MediaRecorder(gptStream, options);

  mediaRecorder.ondataavailable = (e) => {
    if (e.data && e.data.size > 0) currentChunks.push(e.data);
  };

  mediaRecorder.onstop = () => {
    isRecording = false;

    const mime = (mediaRecorder && mediaRecorder.mimeType) ? mediaRecorder.mimeType : "audio/webm";
    const blob = new Blob(currentChunks, { type: mime });

    currentChunks = [];
    mediaRecorder = null;

    // --- Forkast ultrakorte klipp ---
    const clipMs = phraseStartTs ? (performance.now() - phraseStartTs) : 999999;
    if (clipMs < MIN_SEND_MS) {
      phraseRmsSum = 0;
      phraseRmsCount = 0;
      return;
    }

    // --- Forkast ren st√∏y ---
    const meanRms = phraseRmsCount ? (phraseRmsSum / phraseRmsCount) : 0;
    phraseRmsSum = 0;
    phraseRmsCount = 0;

    if (meanRms < MIN_MEAN_RMS) {
      return;
    }

    // dropp tomme klipp
    if (blob && blob.size > 2500) {
      sendQueue.push(blob);
    }
  }; // ‚úÖ VIKTIG: denne m√• finnes

  try {
    mediaRecorder.start();
  } catch (e) {
    isRecording = false;
    mediaRecorder = null;
  }
} // ‚úÖ og denne


function stopRecorderAndQueue() {
  return new Promise((resolve) => {
    if (!mediaRecorder) {
      isRecording = false;
      silenceMs = 0;
      resolve();
      return;
    }

    isRecording = false;
    silenceMs = 0;

    const mr = mediaRecorder;

    // One-shot wrapper rundt onstop for √• kunne restart + resolve
    const prevOnStop = mr.onstop;
    mr.onstop = () => {
      try { prevOnStop && prevOnStop(); } catch (_) {}

      // Start ny recorder automatisk etter klipp
      if (gptRunning && pendingStartAfterStop) {
  pendingStartAfterStop = false;
  startRecorder();
  phraseStartTs = performance.now();
  phraseRmsSum = 0;
  phraseRmsCount = 0;
  silenceMs = 0;
}


      cutting = false;
      resolve();
    };

    try {
      if (mr.state !== "inactive") mr.stop();
      else resolve();
    } catch (e) {
      cutting = false;
      resolve();
    }
  });
}


async function pumpSendQueue() {
  if (sending) return;
  sending = true;

  while (gptRunning || sendQueue.length > 0) {
    if (sendQueue.length === 0) {
      await new Promise(r => setTimeout(r, 80));
      continue;
    }

    const blob = sendQueue.shift();

    try {
      const text = await transcribeAudio(blob);
      if (text && text.trim()) {
        appendText(text.trim());
      } else {
        console.warn("Transcribe: tomt svar");
      }
    } catch (e) {
      console.error("Transcribe failed:", e);
      await new Promise(r => setTimeout(r, 600));
    }
  }

  sending = false;
}




            
        
        function slettDiktatTekst() {
            const diktatTekst = document.getElementById("diktatTekst");
            const diktatStatus = document.getElementById("diktatStatus");
            
            // Slett teksten i diktat-boksen
            diktatTekst.value = "";
            
            // Oppdater status
            diktatStatus.textContent = "Tekstboks t√∏mt. Klar for nytt diktat eller innskriving.";
            
            // Fokuser p√• tekstboksen for enkel innskriving
            diktatTekst.focus();
        }
        
        
        function anonymiserTekst(fromModal = false) {
            const diktatTekst = document.getElementById("diktatTekst");
            const diktatStatus = document.getElementById("diktatStatus");

            if (!diktatTekst || !diktatTekst.value.trim()) {
                if (diktatStatus) diktatStatus.textContent = "Ingen tekst √• anonymisere.";
                return { text: "", items: [], stats: {} };
            }

            // Lagre originalteksten for angre-funksjonalitet
            originalTextBeforeAnonymization = diktatTekst.value;
            const originalTekst = diktatTekst.value;

            // Vis angre-knappen
            const angreBtn = document.getElementById('angreAnonymiseringKnapp');
            if (angreBtn) angreBtn.style.display = 'inline-block';

            // Hent modus fra innstillinger
            const ps = loadPrivacySettings();
            const mode = ps.mode || "hybrid";

            try {
                if (diktatStatus) diktatStatus.textContent = "Anonymiserer tekst... üîí";

                const res = anonymizeText(originalTekst, mode);

                // Oppdater tekstfelt hvis endringer
                const changed = (res.text !== originalTekst);

                if (changed) {
                    diktatTekst.value = res.text;
                    if (diktatStatus) {
                      const total = res.items.length;
                      diktatStatus.textContent = `‚úÖ Tekst anonymisert. ${total} funn maskert. (Ctrl+Z for √• angre)`;
                    }
                } else {
                    if (diktatStatus) diktatStatus.textContent = "‚úÖ Ingen endringer. Teksten ser allerede anonym ut.";
                }

                // Lagre "sist anonymisert" (og vis i modal)
                saveLastAnonymized({ items: res.items, stats: res.stats, mode, at: Date.now() });
                updateLastAnonymizedUI();

                if (fromModal) {
                  // vis preview-boksen med siste resultat
                  const box = document.getElementById("privacyPreviewBox");
                  const ta = document.getElementById("privacyPreviewText");
                  if (box && ta) {
                    box.style.display = "block";
                    ta.value = res.text;
                  }
                }

                // Fokuser p√• tekstboksen
                diktatTekst.focus();

                return res;

            } catch (error) {
                console.error("Feil under anonymisering:", error);
                if (diktatStatus) diktatStatus.textContent = "‚ùå Feil under anonymisering.";
                diktatTekst.value = originalTekst;
                return { text: originalTekst, items: [], stats: {} };
            } finally {
                // Tilbakestill status etter 5 sekunder
                setTimeout(() => {
                    if (diktatStatus) diktatStatus.textContent = "Klar for diktat...";
                }, 5000);
            }
        }

        function angreAnonymisering() {
            const diktatTekst = document.getElementById("diktatTekst");
            const diktatStatus = document.getElementById("diktatStatus");
            
            if (originalTextBeforeAnonymization !== null) {
                diktatTekst.value = originalTextBeforeAnonymization;
                diktatStatus.textContent = "‚úÖ Anonymisering angret! Original tekst gjenopprettet.";
                
                // Skjul angre-knappen
                document.getElementById('angreAnonymiseringKnapp').style.display = 'none';
                
                // Fokuser p√• tekstboksen
                diktatTekst.focus();
                
                // Tilbakestill lagret originaltekst
                originalTextBeforeAnonymization = null;
                
                // Tilbakestill status etter 3 sekunder
                setTimeout(() => {
                    diktatStatus.textContent = "Klar for diktat...";
                }, 3000);
            } else {
                diktatStatus.textContent = "‚ö†Ô∏è Ingen anonymisert tekst √• angre.";
                
                // Tilbakestill status etter 3 sekunder
                setTimeout(() => {
                    diktatStatus.textContent = "Klar for diktat...";
                }, 3000);
            }
        }
        
        // OCR-funksjoner
        function setupFileDropArea() {
            const fileInput = document.getElementById('fileInput');
            const fileDropArea = document.getElementById('fileDropArea');
            const imagePreview = document.getElementById('imagePreview');
            const ocrStatus = document.getElementById('ocrStatus');
            const slettBildeKnapp = document.getElementById('slettBildeKnapp');
            
            // Klikk p√• drop-omr√•de for √• √•pne filvelger
            fileDropArea.addEventListener('click', function() {
                fileInput.click();
            });
            
            // N√•r brukeren velger en fil
            fileInput.addEventListener('change', function(e) {
                handleFileSelect(e.target.files);
            });
            
            // Dra og slipp hendelser
            fileDropArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                fileDropArea.classList.add('dragover');
            });
            
            fileDropArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                fileDropArea.classList.remove('dragover');
            });
            
            fileDropArea.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                fileDropArea.classList.remove('dragover');
                
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    handleFileSelect(e.dataTransfer.files);
                }
            });
            
            function handleFileSelect(files) {
                if (files.length === 0) return;
                
                const file = files[0];
                
                // Sjekk om det er et bilde
                if (!file.type.match('image.*')) {
                    ocrStatus.textContent = 'Vennligst velg et bilde (JPG, PNG, GIF).';
                    return;
                }
                
                // Sjekk filst√∏rrelse (maks 5MB)
                if (file.size > 5 * 1024 * 1024) {
                    ocrStatus.textContent = 'Bildet er for stort. Maks 5MB.';
                    return;
                }
                
                selectedFile = file;
                
                // Vis forh√•ndsvisning
                const reader = new FileReader();
                reader.onload = function(e) {
                    imagePreview.src = e.target.result;
                    imagePreview.style.display = 'block';
                    ocrStatus.textContent = 'Bilde lastet. Klar for OCR-prosessering.';
                    slettBildeKnapp.disabled = false;
                };
                reader.readAsDataURL(file);
            }
        }
        
        function slettBilde() {
            const imagePreview = document.getElementById('imagePreview');
            const ocrStatus = document.getElementById('ocrStatus');
            const slettBildeKnapp = document.getElementById('slettBildeKnapp');
            
            selectedFile = null;
            imagePreview.style.display = 'none';
            imagePreview.src = '';
            ocrStatus.textContent = 'Klar for bildeopplasting...';
            slettBildeKnapp.disabled = true;
        }
        
        async function limInnFraUtklippstavle() {
            const ocrStatus = document.getElementById('ocrStatus');
            const imagePreview = document.getElementById('imagePreview');
            const slettBildeKnapp = document.getElementById('slettBildeKnapp');
            
            try {
                // Sjekk om Clipboard API er tilgjengelig
                if (!navigator.clipboard || !navigator.clipboard.read) {
                    ocrStatus.textContent = '‚ùå Utklippstavle-tilgang ikke tilgjengelig. Bruk Chrome, Edge eller Firefox.';
                    return;
                }
                
                // Be om tillatelse til √• lese fra utklippstavle
                const permissionStatus = await navigator.permissions.query({ name: 'clipboard-read' });
                
                if (permissionStatus.state === 'denied') {
                    ocrStatus.textContent = '‚ùå Tillatelse til utklippstavle nektet. Gi tillatelse i nettleserinnstillinger.';
                    return;
                }
                
                // Les fra utklippstavle
                ocrStatus.textContent = 'Lese fra utklippstavle...';
                const clipboardItems = await navigator.clipboard.read();
                
                // Finn bilde fra utklippstavle
                for (const clipboardItem of clipboardItems) {
                    for (const type of clipboardItem.types) {
                        if (type.startsWith('image/')) {
                            // Hent bildeblob
                            const blob = await clipboardItem.getType(type);
                            
                            // Konverter til filobjekt
                            selectedFile = new File([blob], 'clipboard-image.png', { type: blob.type });
                            
                            // Vis forh√•ndsvisning
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                imagePreview.src = e.target.result;
                                imagePreview.style.display = 'block';
                                ocrStatus.textContent = '‚úÖ Bilde hentet fra utklippstavle! Klar for OCR.';
                                slettBildeKnapp.disabled = false;
                            };
                            reader.readAsDataURL(selectedFile);
                            
                            return;
                        }
                    }
                }
                
                // Ingen bilde funnet
                ocrStatus.textContent = '‚ö†Ô∏è Ingen bilde funnet i utklippstavle. Kopier et bilde f√∏rst.';
                
            } catch (error) {
                console.error('Feil ved lesing fra utklippstavle:', error);
                
                if (error.name === 'NotAllowedError') {
                    ocrStatus.textContent = '‚ùå Tillatelse til utklippstavle nektet. Klikk p√• siden og pr√∏v igjen.';
                } else if (error.name === 'NotFoundError') {
                    ocrStatus.textContent = '‚ö†Ô∏è Ingen bilde funnet i utklippstavle. Kopier et bilde f√∏rst.';
                } else {
                    ocrStatus.textContent = `‚ùå Feil: ${error.message}`;
                }
            }
        }
        
        async function startOCR() {
            const ocrKnapp = document.getElementById('ocrKnapp');
            const ocrStatus = document.getElementById('ocrStatus');
            const diktatTekst = document.getElementById('diktatTekst');
            
            if (!selectedFile) {
                ocrStatus.textContent = 'Vennligst last opp et bilde f√∏rst.';
                return;
            }
            
            if (isProcessingOCR) {
                ocrStatus.textContent = 'OCR-prosessering p√•g√•r allerede...';
                return;
            }
            
            // Vis loading-tilstand
            isProcessingOCR = true;
            ocrKnapp.classList.add('loading');
            ocrKnapp.disabled = true;
            ocrStatus.textContent = 'Prosesserer bilde med OCR... Dette kan ta litt tid.';
            
            try {
                // Bruk Tesseract.js v5 API for OCR
                const { data: { text } } = await Tesseract.recognize(
                    selectedFile,
                    'nor', // Norsk spr√•k
                    {
                        logger: m => {
                            console.log('OCR:', m);
                            if (m.status === 'recognizing text') {
                                ocrStatus.textContent = `OCR-prosessering: ${Math.round(m.progress * 100)}% fullf√∏rt`;
                            }
                        }
                    }
                );
                
                // Legg til OCR-teksten i diktatfeltet
                if (text.trim()) {
                    diktatTekst.value = text;
                    ocrStatus.textContent = '‚úÖ OCR fullf√∏rt! Tekst hentet fra bilde. Teksten er fortsatt kun p√• din maskin.';
                    
                    // Automatisk velg OCR-korrektur prompt for best resultat
                    velgPromptVedId('ocr_korrektur');
                    
                    // Fokuser p√• diktatfeltet
                    diktatTekst.focus();
                    diktatTekst.scrollTop = 0;
                } else {
                    ocrStatus.textContent = '‚ö†Ô∏è Ingen tekst funnet i bildet.';
                }
                
            } catch (error) {
                console.error('OCR-feil:', error);
                ocrStatus.textContent = `‚ùå OCR-feil: ${error.message}. Pr√∏v et annet bilde.`;
                
                // Pr√∏v med engelsk som fallback hvis norsk feiler
                if (error.message.includes('Failed to load language')) {
                    ocrStatus.textContent += ' Pr√∏ver med engelsk...';
                    
                    try {
                        const { data: { text } } = await Tesseract.recognize(
                            selectedFile,
                            'eng', // Engelsk som fallback
                            {
                                logger: m => console.log('OCR fallback:', m)
                            }
                        );
                        
                        if (text.trim()) {
                            diktatTekst.value = text;
                            ocrStatus.textContent = '‚úÖ OCR fullf√∏rt med engelsk! Tekst hentet fra bilde.';
                            diktatTekst.focus();
                            diktatTekst.scrollTop = 0;
                        }
                    } catch (fallbackError) {
                        console.error('Fallback OCR-feil:', fallbackError);
                        ocrStatus.textContent = `‚ùå Begge OCR-fors√∏k feilet. Pr√∏v et klarere bilde.`;
                    }
                }
            } finally {
                // Tilbakestill UI
                isProcessingOCR = false;
                ocrKnapp.classList.remove('loading');
                ocrKnapp.disabled = false;
                
                // Tilbakestill status etter 5 sekunder
                setTimeout(() => {
                    if (ocrStatus.textContent.includes('OCR fullf√∏rt') || 
                        ocrStatus.textContent.includes('Ingen tekst funnet')) {
                        ocrStatus.textContent = 'Klar for ny bildeopplasting.';
                    }
                }, 5000);
            }
        }
        
        function kopierTilUtklippstavle() {
            const resultatTekst = document.getElementById("resultatTekst");
            const diktatStatus = document.getElementById("diktatStatus");
            
            if (!resultatTekst.textContent) {
                diktatStatus.textContent = "Ingen tekst √• kopiere. Send diktatet til GPT f√∏rst.";
                return;
            }
            
            navigator.clipboard.writeText(resultatTekst.textContent).then(() => {
                diktatStatus.textContent = "Teksten er kopiert til utklippstavlen! üìã";
                // Tilbakestill status etter 3 sekunder
                setTimeout(() => {
                    diktatStatus.textContent = "Klar for diktat...";
                }, 3000);
            }).catch(err => {
                console.error("Kunne ikke kopiere tekst:", err);
                diktatStatus.textContent = "Kunne ikke kopiere tekst. Pr√∏v √• markere teksten manuelt og kopier med Ctrl+C.";
            });
        }
        
        function flyttResultatTilDiktat() {
            const resultatTekst = document.getElementById("resultatTekst");
            const diktatTekst = document.getElementById("diktatTekst");
            
            if (!resultatTekst.textContent) {
                alert("Ingen resultat √• flytte. Send diktatet til GPT f√∏rst.");
                return;
            }
            
            // Flytt resultatet til diktat-tekstboksen og overskriv det som st√•r der
            diktatTekst.value = resultatTekst.textContent;
            
            // Gi brukeren tilbakemelding
            alert("Resultatet er flyttet til diktat-tekstboksen! üîÑ");
            
            // Rull til toppen av diktat-tekstboksen
            diktatTekst.scrollTop = 0;
            diktatTekst.focus();
        }
        
async function sendTilGPT() {
    const sendKnapp = document.getElementById("sendKnapp");
    const feilMelding = document.getElementById("feilMelding");
    const resultat = document.getElementById("result");
    const diktatTekst = document.getElementById("diktatTekst");

    // Rate limit cooldown (prevents accidental loops from spamming the backend)
    if (nf_inCooldown(nf_responsesCooldownUntil)) {
        const sec = Math.ceil((nf_responsesCooldownUntil - Date.now()) / 1000);
        nf_disableButtonForSeconds(sendKnapp, sec, "Vent litt");
        if (feilMelding) feilMelding.textContent = `Vent litt (${sec}s) f√∏r du pr√∏ver igjen.`;
        return;
    }

    resultat.style.display = "none";
    feilMelding.style.display = "none";

    // Rate limit
    const now = Date.now();
    if (now - lastRequestTime < REQUEST_DELAY) {
        const remainingTime = Math.ceil((REQUEST_DELAY - (now - lastRequestTime)) / 1000);
        feilMelding.textContent = `Vennligst vent ${remainingTime} sekunder mellom foresp√∏rsler.`;
        feilMelding.style.display = "block";
        return;
    }
    
    lastRequestTime = now;

    sendKnapp.classList.add("loading");
    sendKnapp.disabled = true;

    try {
        const modell = document.getElementById("modell").value;
        const promptType = document.getElementById("promptType").value;
        let tekst = diktatTekst.value.trim();
        const spr√•k = document.getElementById("stikkord").value.trim();

                if (!tekst) throw new Error("Ingen tekst √• sende.");


// Auto-anonymiser f√∏r sending (st√∏ttefunksjon ‚Äì brukeren m√• fortsatt vurdere innholdet)
try {
        const ps = loadPrivacySettings();
        if (ps && ps.autoAnonymize) anonymiserTekst(false);
            // Re-les tekst etter anonymisering (viktig: ellers sendes originaltekst)
        tekst = diktatTekst.value.trim();
} catch(e) {}

        // 1) Hent prompt-maler (kun JSON)
        const promptMaler = await hentPromptMaler();

        // 2) Finn korrekt mal via id
        const mal = promptMaler.find(m => m.id === promptType);
        if (!mal) {
            throw new Error(`Fant ingen prompt-mal med id="${promptType}" i prompt_maler.json`);
        }

        // 3) Valider n√∏dvendige variabler
        if (mal.prompt.includes("[SPR√ÖK]") && !spr√•k) {
            throw new Error("Denne prompten krever at du fyller inn spr√•k i stikkord-feltet.");
        }

        // 4) Hent relevante maler lokalt (kun for enkelte innebygde prompter)
//    Dette erstatter [MAL_DATABASE].
let malDatabase = "";
const cfg = getTemplateSelectConfigForPrompt(promptType);
if (cfg && mal.prompt.includes("[MAL_DATABASE]")) {
    let selected = selectRelevantTemplates(tekst, cfg);

    // Fallback: hvis ingen treff, men malbank finnes, send med et lite utvalg (recent)
    if (!selected.length) {
        const all = getAllTemplates();
        if (all.length) {
            selected = fallbackTemplates(all, { maxTemplates: Math.min(3, cfg.maxTemplates || 3), maxCharsPerTemplate: 1800, maxTotalChars: cfg.maxTotalChars || 11000 });
        }
    }

    if (selected.length) {
        const isFallback = selected.every(t => (t.score || 0) === 0);
        const heading = false
          ? (isFallback ? "Malbank (ingen direkte treff ‚Äì viser siste maler):" : "Malbank (utvalg fra lokal malbank):")
          : (isFallback ? "Relevante maler (ingen direkte treff ‚Äì viser siste maler):" : "Relevante maler (utvalg fra lokal malbank):");

        const attachment = renderTemplatesAttachment(selected, heading);


        // Statuslinje: vis hvilke maler som ble valgt
        try {
          const st = document.getElementById("templateSelectionStatus");
          if (st) {
            const list = selected.map(t => `${t.title}${typeof t.score === "number" ? ` (${t.score})` : ""}`).join(" ‚Ä¢ ");
            st.textContent = list ? `Valgte maler: ${list}` : "";
          }
        } catch (e) {}
        // Vi fyller begge plassholdere med samme vedleggstekst.
        malDatabase = attachment;
    } else {
        // Ingen relevante maler ‚Äì la plassholderne bli tomme
        malDatabase = "";
        try { const st = document.getElementById("templateSelectionStatus"); if (st) st.textContent = "Ingen maler valgt."; } catch(e) {}
    }
} else {
    try { const st = document.getElementById("templateSelectionStatus"); if (st) st.textContent = ""; } catch(e) {}
}


// 5) Bygg ferdig prompt
        const prompt = mal.prompt
            .replaceAll("[TEKST_INNHOLD]", tekst)
            .replaceAll("[SPR√ÖK]", spr√•k)
            .replaceAll("[MAL_DATABASE]", malDatabase)
            ;

        
// 6) Send til backend (som proxy'er til OpenAI Responses API)
// Viktig: vi sender *kun* allerede anonymisert tekst videre (hjelper litt, men brukeren m√• fortsatt vurdere innholdet).
const respons = await apiFetchAuthed("/api/responses", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    model: modell,
    input: prompt
  })
});

        

if (!respons.ok) {
    if (respons.status === 429) {
        const sec = nf_getRetryAfterSeconds(respons, 20);
        nf_responsesCooldownUntil = Date.now() + sec * 1000;
        nf_disableButtonForSeconds(sendKnapp, sec, "Vent litt");
        throw new Error(`For mange foresp√∏rsler. Pr√∏v igjen om ${sec}s.`);
    }
    const errTxt = await respons.text().catch(() => "");
    throw new Error(`API-feil (${respons.status})${errTxt ? ": " + errTxt : ""}`);
}

const data = await respons.json();

// üëá faktisk modell brukt av OpenAI
const faktiskModell = data.model || "ukjent";

// Vis i statusfeltet
const diktatStatus = document.getElementById("diktatStatus");
diktatStatus.textContent = `ü§ñ GPT-modell brukt: ${faktiskModell}`;

        // Fors√∏k √• hente tekst p√• flere kompatible m√•ter
        let resultatTekst = "";
        if (typeof data.output_text === "string") {
            resultatTekst = data.output_text;
        } else if (Array.isArray(data.output)) {
            // typisk struktur: output -> [{content:[{type:"output_text", text:"..."}]}]
            for (const item of data.output) {
                if (!item || !Array.isArray(item.content)) continue;
                for (const c of item.content) {
                    if (c && typeof c.text === "string") {
                        resultatTekst += (resultatTekst ? "\n\n" : "") + c.text;
                    }
                }
            }
        }

        if (!resultatTekst) {
            // fallback: vis hele objektet for debugging (kort)
            console.warn("Uventet svarformat fra OpenAI:", data);
            throw new Error("Fikk svar fra OpenAI, men klarte ikke √• lese ut tekst (uventet format). Se konsoll.");
        }

        resultatTekst = resultatTekst.replace(/^"|"$/g, "");

        document.getElementById("resultatTekst").textContent = resultatTekst;
        resultat.style.display = "block";

        console.log(`Prompt sendt til GPT via JSON-id: ${promptType}`);

    } catch (error) {
        console.error(error);
        feilMelding.textContent = error.message;
        feilMelding.style.display = "block";
    } finally {
        sendKnapp.classList.remove("loading");
        sendKnapp.disabled = false;
    }
}

        
        // Database-funksjoner
        async function hentMalDatabase() {
            try {
                const response = await fetch(apiUrl("/api/hent_database"));
                if (!response.ok) {
                    throw new Error(`Serverfeil: ${response.status}`);
                }
                
                const result = await response.json();
                if (result.status === "success") {
                    return result.content;
                } else {
                    console.log("Ingen mal-database funnet, returnerer tom streng");
                    return "";
                }
            } catch (error) {
                console.error("Feil ved henting av mal-database:", error);
                return "";
            }
        }
        
        async function lagreTilDatabase(korrigertTekst, promptType, originalTekst = "", databaseType = "generell") {
            try {
                const response = await fetch(apiUrl("/api/lagre_mal"), {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        tekst: korrigertTekst,
                        prompt_type: promptType,
                        original_tekst: originalTekst,
                        database_type: databaseType
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Serverfeil: ${response.status}`);
                }
                
                const result = await response.json();
                if (result.status === "success") {
                    console.log("Mal lagret");
                    return true;
                }
                return false;
            } catch (error) {
                console.error("Lagringsfeil:", error);
                return false;
            }
        }
        
        async function lagreTilDatabaseManuelt(databaseType = "generell") {
            const resultatTekst = document.getElementById("resultatTekst");
            const promptType = document.getElementById("promptType").value;
            
            if (!resultatTekst.textContent) {
                alert("Ingen resultat √• lagre. Send diktatet til GPT f√∏rst.");
                return;
            }
            
            const lagreKnapp = document.getElementById("lagreGenerellKnapp");
            const originalTekst = lagreKnapp.textContent;
            
            // Vis loading-effekt
            lagreKnapp.textContent = "Lagrer... üíæ";
            lagreKnapp.disabled = true;
            
            try {
                // Send originalteksten for henvendelseer
                const originalTekstInnhold = "";
const success = await lagreTilDatabase(resultatTekst.textContent, promptType, originalTekstInnhold, "generell");
                
                if (success) {
                    const databaseNavn = "mal-database";
                    alert(`Resultatet er lagret i ${databaseNavn}! üíæ`);
                    const diktatStatus = document.getElementById("diktatStatus");
                    diktatStatus.textContent = `Resultat lagret i ${databaseNavn}!`;
                } else {
                    alert("Lagringsfeil. Pr√∏v igjen eller sjekk om serveren kj√∏rer.");
                }
            } catch (error) {
                console.error("Lagringsfeil:", error);
                alert("Lagringsfeil. Pr√∏v igjen eller sjekk om serveren kj√∏rer.");
            } finally {
                // Gjenopprett knapp-tilstand
                lagreKnapp.textContent = originalTekst;
                lagreKnapp.disabled = false;
            }
        }
        
        async function visMalDatabase() {
            try {
                const response = await fetch(apiUrl("/api/hent_database"));
                if (!response.ok) {
                    throw new Error(`Serverfeil: ${response.status}`);
                }
                
                const result = await response.json();
                if (result.status === "success") {
                    document.getElementById("databaseInnhold").textContent = result.content;
                    document.getElementById("databaseVisning").style.display = "block";
                } else {
                    throw new Error(result.message);
                }
            } catch (error) {
                alert(`Feil: ${error.message}. Er Python-serveren startet?`);
            }
        }
        
        async function eksporterMalDatabase() {
            try {
                const response = await fetch(apiUrl("/api/hent_database"));
                if (!response.ok) {
                    throw new Error(`Serverfeil: ${response.status}`);
                }
                
                const result = await response.json();
                if (result.status !== "success") {
                    throw new Error(result.message);
                }
                
                const blob = new Blob([result.content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mal_database_backup_${new Date().toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert("Database eksportert!");
            } catch (error) {
                alert(`Feil: ${error.message}`);
            }
        }
    async function sendTilGPT_guarded() {
  // Gratis-brukere skal kunne bruke GPT innenfor backend-kvoter (krever innlogging)
  await softGate.requireLogin(async () => {
    await sendTilGPT();
  });
}

function startGPT4oDiktat_guarded() {
  // Diktat/transcribe (realtime) er Pro
  requirePro(() => {
    startGPT4oDiktat();
  }, "Diktat/transcribe (realtime) er Pro i denne fasen.");
}


     





   // Fanebytter-funksjon

/* =========================================================
   Skriveflyt: 2 faner for transkripsjon
   - Realtime: kontinuerlige "completed turns" fra WS
   - Fullfil: √©n samlet transkripsjon som lages ved stopp (tilvalg)
   ========================================================= */
let nf_activeTab = "rt";          // "rt" | "full"
let nf_rtText = "";
let nf_fullText = "";
let nf_fullEnabled = false;

let nf_fullRecorder = null;
let nf_fullChunks = [];
let nf_fullBlobStored = null;


function nf_setTab(tab){
  nf_activeTab = (tab === "full") ? "full" : "rt";
  const rtBtn = document.getElementById("tabRealtime");
  const ffBtn = document.getElementById("tabFullfile");
  const hint = document.getElementById("fullfileHint");
  const ta = document.getElementById("diktatTekst");
  if (!ta) return;

  if (rtBtn && ffBtn){
    rtBtn.classList.toggle("active", nf_activeTab === "rt");
    ffBtn.classList.toggle("active", nf_activeTab === "full");
    rtBtn.setAttribute("aria-selected", nf_activeTab === "rt" ? "true" : "false");
    ffBtn.setAttribute("aria-selected", nf_activeTab === "full" ? "true" : "false");
  }

  // vis hint bare n√•r full-tabben er valgt og vi ikke har tekst enn√•
  if (hint){
    const showHint = (nf_activeTab === "full") && (!nf_fullText || nf_fullText.trim().length === 0);
    hint.style.display = showHint ? "block" : "none";
  }

  ta.value = (nf_activeTab === "rt") ? (nf_rtText || "") : (nf_fullText || "");
  ta.scrollTop = ta.scrollHeight;
}

function nf_resetTranscripts(){
  nf_rtText = "";
  nf_fullText = "";
  nf_fullBlobStored = null;
  nf_setRunButtonEnabled(false);
  nf_setTab("rt");
}

function nf_setRunButtonEnabled(on){
  const btn = document.getElementById("btnRunFullfile");
  if (btn) btn.disabled = !on;
}


function nf_appendRealtimeFinal(t){
  const s = (t || "").trim();
  if (!s) return;

  const before = nf_rtText || "";
  const needsSpace = before && !before.endsWith("\n") && !before.endsWith(" ");
  nf_rtText = before + (needsSpace ? " " : "") + s + "\n";

  if (nf_activeTab === "rt") {
    const ta = document.getElementById("diktatTekst");
    if (ta){
      ta.value = nf_rtText;
      ta.scrollTop = ta.scrollHeight;
    }
  }
}

async function nf_transcribeFullBlob(blob){
  // transcribeAudio(blob) finnes allerede i filen (bruker /api/transcribe)
  const txt = await transcribeAudio(blob);
  nf_fullText = (txt || "").trim();
  // oppdater hint
  const hint = document.getElementById("fullfileHint");
  if (hint) hint.style.display = "none";
  if (nf_activeTab === "full") {
    const ta = document.getElementById("diktatTekst");
    if (ta){
      ta.value = nf_fullText || "";
      ta.scrollTop = ta.scrollHeight;
    }
  }
}


// === Prompt Editor ===
function escapeRegExp(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
const PROMPT_DB_KEY = "promptMaler_v1";
const PROMPT_DB_SCHEMA_VERSION = "1";
const MAL_DB_BLOCK = `
Relevante maler fra database:
"""
[MAL_DATABASE]
"""
`.trim();
const TEXT_BLOCK = `
Tekst:
"""
[TEKST_INNHOLD]
"""
`.trim();




// Default prompt-maler som alltid ligger inne (seedes til LocalStorage ved f√∏rste oppstart)
// Default prompt-maler som alltid ligger inne (seedes til LocalStorage ved f√∏rste oppstart)
const DEFAULT_PROMPT_MALER = (function(){
  const raw = String.raw`{
  "promptMaler": [
    {
      "id": "korrektur",
      "type": "Korrektur",
      "beskrivelse": "Rett spr√•k, flyt og tegnsetting uten √• endre mening",
      "hotkey": 1,
      "prompt": "Korriger teksten under for spr√•k, flyt og tegnsetting. Bevar mening og stil. Ikke legg til nytt innhold.\n\nTekst:\n\"\"\"[TEKST_INNHOLD]\"\"\""
    },
    {
      "id": "oversett_engelsk",
      "type": "Oversett til engelsk",
      "beskrivelse": "Flytende, naturlig engelsk",
      "hotkey": 2,
      "prompt": "Oversett f√∏lgende tekst til engelsk.\nGi en flytende, naturlig oversettelse som bevarer original mening. IKKE bruk markeringer som ** eller * ‚Äì returner ren tekst. Returner KUN den oversatte teksten.\n\nOriginal tekst:\n\"\"\"[TEKST_INNHOLD]\"\"\""
    },
    {
      "id": "oversett_annet",
      "type": "Oversett til annet spr√•k",
      "beskrivelse": "For oversettelse til andre spr√•k (krever stikkord)",
      "hotkey": 3,
      "prompt": "Oversett f√∏lgende tekst til [SPR√ÖK].\nGi en flytende, naturlig oversettelse som bevarer original mening. IKKE bruk markeringer som ** eller * ‚Äì returner ren tekst. Returner KUN den oversatte teksten.\n\nOriginal tekst:\n\"\"\"[TEKST_INNHOLD]\"\"\""
    },
    {
      "id": "forklar_tekst",
      "type": "Forklar vanskelig tekst",
      "beskrivelse": "Gj√∏r en tekst enklere √• forst√• (uten √• forvrenge innholdet)",
      "hotkey": 4,
      "prompt": "Forklar teksten under p√• en enkel og tydelig m√•te, tilpasset en vanlig leser.\n- Bevar fakta og mening\n- Forklar faguttrykk\n- Hold det kort og konkret\n\nTekst:\n\"\"\"[TEKST_INNHOLD]\"\"\""
    },
    {
      "id": "sammendrag",
      "type": "Sammendrag / notat",
      "beskrivelse": "Lag et strukturert sammendrag av teksten",
      "hotkey": 5,
      "prompt": "Lag et kort, strukturert sammendrag av teksten under.\nBruk gjerne punkter og underoverskrifter.\n\nTekst:\n\"\"\"[TEKST_INNHOLD]\"\"\""
    },
    {
      "id": "ocr_korrektur",
      "type": "OCR-korrektur",
      "beskrivelse": "Rydd opp i tekst fra bilde/PDF (OCR): linjeskift, s√¶rtegn, ord-feil",
      "hotkey": 6,
      "prompt": "Du er en ekspert p√• √• korrigere tekst generert av OCR.\nRett typiske OCR-feil (feil tegn, ord-deling, rare linjeskift), og formater teksten slik at den blir lett √• lese.\nBevar innholdet ‚Äì ikke finn p√• nye fakta.\n\nOCR-tekst som skal korrigeres:\n\"\"\"[TEKST_INNHOLD]\"\"\""
    },
    {
      "id": "malbasert",
      "type": "Malbasert utfylling",
      "beskrivelse": "Skriv/utfyll tekst basert p√• maler (bruker mal-database)",
      "hotkey": 7,
      "prompt": "Du skal produsere en ferdig tekst ved √• kombinere innholdet brukeren har skrevet med relevante maler fra databasen.\n\nRegler:\n- Velg og bruk bare det som er relevant fra malene\n- Bevar brukerens fakta og intensjon\n- Skriv i en naturlig og konsistent stil\n- Returner kun ferdig tekst (ingen forklaringer)\n\nBrukerens tekst:\n\"\"\"[TEKST_INNHOLD]\"\"\"\n\nRelevante maler fra database:\n\"\"\"[MAL_DATABASE]\"\"\""
    }
  ]
}`;
  try {
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : (parsed.promptMaler || []);
  } catch (e) {
    console.error("Kunne ikke parse innebygde default prompt-maler:", e);
    return [];
  }
})();
let pe_maler = [];
let pe_selected = -1;
let pe_dirty = false;

function pe_show(open) {
  document.getElementById("promptEditorModal").style.display = open ? "block" : "none";
}

function pe_setStatus(msg) {
  document.getElementById("pe_status").textContent = msg || "";
}

async function pe_fetchPrompts() {
  // Les prompt-maler KUN fra LocalStorage
  const maler = await hentPromptMaler();
  return Array.isArray(maler) ? maler : [];
}

async function pe_savePrompts(list) {
  // Lagre prompt-maler lokalt i LocalStorage (ingen sentral lagring av innhold)
  const payload = {
    schemaVersion: PROMPT_DB_SCHEMA_VERSION,
    updatedAt: new Date().toISOString(),
    promptMaler: list
  };
  localStorage.setItem(PROMPT_DB_KEY, JSON.stringify(payload));
  return true;
}
async function pe_resetToFactoryPrompts() {
  if (pe_dirty && !confirm("Du har ulagrede endringer. Fortsette og overskrive alt?")) return;

  const ok = confirm(
    "Dette vil gjenopprette fabrikk-prompter og SLETTE alle dine egne prompter.\n\nFortsette?"
  );
  if (!ok) return;

  // Lag en ren kopi + normaliser felter
  const factory = (Array.isArray(DEFAULT_PROMPT_MALER) ? DEFAULT_PROMPT_MALER : []).map(p => ({
    id: String(p.id || "").trim(),
    hotkey: (p.hotkey ?? null),
    type: p.type ?? "",
    beskrivelse: p.beskrivelse ?? "",
    prompt: p.prompt ?? ""
  }));

  // Valider og lagre direkte til LocalStorage
  pe_validate(factory);
  await pe_savePrompts(factory);

  // Oppdater editor-state
  pe_maler = factory;
  pe_selected = pe_maler.length ? 0 : -1;
  pe_dirty = false;

  // Oppdater UI
  document.getElementById("promptSearch").value = "";
  pe_renderList();
  pe_fillForm(pe_selected >= 0 ? pe_maler[pe_selected] : null);

  // Oppdater dropdown + hotkeys i hovedskjerm
  await byggPromptDropdown({ beholdValg: false, sorter: false });

  // hvis du bruker cache
  if (typeof _promptMalerCache !== "undefined") _promptMalerCache = null;

  pe_setStatus("Gjenopprettet fabrikk-prompter ‚úÖ");
}


function pe_renderList() {
  const q = (document.getElementById("promptSearch").value || "").trim().toLowerCase();
  const container = document.getElementById("promptList");
  container.innerHTML = "";

  pe_maler.forEach((m, idx) => {
    const hay = `${m.id||""} ${m.type||""}`.toLowerCase();
    if (q && !hay.includes(q)) return;

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "pe-item" + (idx === pe_selected ? " active" : "");
    btn.innerHTML = `
      <div class="k">${m.id || "&lt;mangler id&gt;"}</div>
      <div class="s">${(m.type || "")}${m.beskrivelse ? " ‚Äî " + m.beskrivelse : ""}</div>
    `;
    btn.onclick = () => pe_select(idx);
    container.appendChild(btn);
  });
}

document.addEventListener("DOMContentLoaded", () => {
  const cb = document.getElementById("pe_useMalDatabase");
  if (!cb) return;

  cb.addEventListener("change", (e) => {
  const ta = document.getElementById("pe_prompt");
  if (!ta) return;

  const checked = e.target.checked;
  const val = ta.value || "";

  if (checked) {
    if (!val.includes("[MAL_DATABASE]")) {
      ta.value = val.trimEnd() + "\n\n" + MAL_DB_BLOCK + "\n";
    }
  } else {
    ta.value = val.replace(
      new RegExp("\\n*" + escapeRegExp(MAL_DB_BLOCK) + "\\n*", "m"),
      "\n"
    ).trimEnd();
  }

  pe_dirty = true;
  pe_setStatus("Ulagrede endringer");
  pe_applyFormToSelected(); // ‚úÖ dette manglet
});

});



function pe_fillForm(m) {
  document.getElementById("pe_id").value = m?.id ?? "";
document.getElementById("pe_hotkey").value = (m?.hotkey ?? "");
  document.getElementById("pe_type").value = m?.type ?? "";
  document.getElementById("pe_beskrivelse").value = m?.beskrivelse ?? "";
  document.getElementById("pe_prompt").value = m?.prompt ?? "";
const cb = document.getElementById("pe_useMalDatabase");
  if (cb) cb.checked = (m?.prompt || "").includes("[MAL_DATABASE]");
}

function pe_readForm() {
  const rawHotkey = document.getElementById("pe_hotkey").value.trim();

  return {
    id: document.getElementById("pe_id").value.trim(),
    hotkey: rawHotkey === "" ? null : Number(rawHotkey),
    type: document.getElementById("pe_type").value,
    beskrivelse: document.getElementById("pe_beskrivelse").value,
    prompt: document.getElementById("pe_prompt").value
  };
}


function pe_select(idx) {
  pe_selected = idx;
  pe_fillForm(pe_maler[idx]);
  pe_renderList();
  pe_setStatus(pe_dirty ? "Ulagrede endringer" : "Klar");
}

function pe_markDirty() {
  pe_dirty = true;
  pe_setStatus("Ulagrede endringer");
  pe_renderList();
}

function pe_applyFormToSelected() {
  if (pe_selected < 0) return;
  pe_maler[pe_selected] = pe_readForm();
  pe_markDirty();
}

function pe_validate(list) {
  // id m√• finnes og v√¶re unik
  for (const m of list) {
    if (!m.id || !m.id.trim()) throw new Error("Alle prompter m√• ha en id (kan ikke v√¶re tom).");
  }
  const ids = list.map(m => m.id.trim());
  const seenIds = new Set();
  for (const id of ids) {
    if (seenIds.has(id)) throw new Error(`Du har duplikat id: "${id}"`);
    seenIds.add(id);
  }

  // prompt m√• finnes
  for (const m of list) {
    if (!m.prompt || !m.prompt.length) throw new Error(`Prompt mangler tekst for id "${m.id}"`);
  }

  // hotkey: hvis satt, m√• v√¶re 1‚Äì9 og unik
  const seenHotkeys = new Set();
  for (const m of list) {
    if (m.hotkey === null || m.hotkey === undefined || m.hotkey === "") continue;

    const hk = Number(m.hotkey);
    if (!Number.isInteger(hk) || hk < 1 || hk > 9) {
      throw new Error(`Hotkey for "${m.id}" m√• v√¶re et heltall 1‚Äì9 (eller tom).`);
    }
    if (seenHotkeys.has(hk)) {
      throw new Error(`Du har duplikat hotkey Ctrl+${hk}. Hver hotkey m√• v√¶re unik.`);
    }
    seenHotkeys.add(hk);
for (const m of list) {
  if (!m.prompt.includes("[TEKST_INNHOLD]")) {
    throw new Error(`Prompt "${m.id}" ‚ùåmangler [TEKST_INNHOLD].`);
  }
}
  }
}


async function pe_openAndLoad() {
  pe_show(true);
  pe_setStatus("Laster...");
  pe_dirty = false;

  pe_maler = await pe_fetchPrompts();
  pe_selected = pe_maler.length ? 0 : -1;

  pe_renderList();
  pe_fillForm(pe_selected >= 0 ? pe_maler[pe_selected] : null);

  pe_setStatus("Klar");
}

function pe_newPrompt() {
  const ny = {
    id: "ny_prompt",
    type: "Ny prompt",
    beskrivelse: "",
    prompt: TEXT_BLOCK + "\n"
  };
  pe_maler.push(ny);
  pe_selected = pe_maler.length - 1;
  pe_fillForm(ny);
  pe_dirty = true;
  pe_renderList();
  pe_setStatus("Ny prompt opprettet (ulagrte endringer)");
}


function pe_duplicatePrompt() {
  if (pe_selected < 0) return;
  const base = pe_maler[pe_selected];
  const copy = JSON.parse(JSON.stringify(base));
  copy.id = base.id + "_kopi";
  pe_maler.push(copy);
  pe_selected = pe_maler.length - 1;
  pe_fillForm(copy);
  pe_dirty = true;
  pe_renderList();
  pe_setStatus("Duplisert (ulagrte endringer)");
}

function pe_deletePrompt() {
  if (pe_selected < 0) return;
  if (!confirm(`Slette prompt "${pe_maler[pe_selected].id}"?`)) return;
  pe_maler.splice(pe_selected, 1);
  pe_selected = Math.min(pe_selected, pe_maler.length - 1);
  pe_fillForm(pe_selected >= 0 ? pe_maler[pe_selected] : null);
  pe_dirty = true;
  pe_renderList();
  pe_setStatus("Slettet (ulagrte endringer)");
}

async function pe_save() {
  pe_applyFormToSelected();

  pe_setStatus("Validerer...");
  pe_validate(pe_maler);

  pe_setStatus("Lagrer...");
  await pe_savePrompts(pe_maler);

  // Oppdater dropdown + hotkeys fra nyeste JSON
  await byggPromptDropdown({ beholdValg: true, sorter: false });

  // hvis du har cache i hentPromptMalerCached:
  if (typeof _promptMalerCache !== "undefined") _promptMalerCache = null;

  pe_dirty = false;
  pe_setStatus("Lagret ‚úÖ");
}


// === Hook up events (m√• ligge etter at DOM-elementene finnes) ===
document.getElementById("btnOpenPromptEditor").addEventListener("click", () => {
  pe_openAndLoad().catch(e => pe_setStatus("Feil: " + e.message));
});

document.getElementById("btnClosePromptEditor").addEventListener("click", () => {
  if (pe_dirty && !confirm("Du har ulagrte endringer. Lukke uten √• lagre?")) return;
  pe_show(false);
});

document.getElementById("btnNewPrompt").addEventListener("click", pe_newPrompt);
document.getElementById("btnDuplicatePrompt").addEventListener("click", pe_duplicatePrompt);
document.getElementById("btnDeletePrompt").addEventListener("click", pe_deletePrompt);

document.getElementById("btnSavePrompts").addEventListener("click", () => {
  pe_save().catch(e => pe_setStatus("Feil: " + e.message));
});

document.getElementById("btnReloadPrompts").addEventListener("click", () => {
  pe_openAndLoad().catch(e => pe_setStatus("Feil: " + e.message));
});

document.getElementById("btnExportPrompts").addEventListener("click", () => {
  try {
    pe_applyFormToSelected();
    pe_validate(pe_maler);
    const payload = {
      schemaVersion: PROMPT_DB_SCHEMA_VERSION,
      exportedAt: new Date().toISOString(),
      promptMaler: pe_maler
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "prompt-maler.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(a.href), 500);
    pe_setStatus("Eksportert prompt-maler.json");
  } catch (e) {
    pe_setStatus("Feil: " + e.message);
  }
});

document.getElementById("btnFactoryPrompts").addEventListener("click", () => {
  pe_resetToFactoryPrompts().catch(e => pe_setStatus("Feil: " + e.message));
});


document.getElementById("btnImportPrompts").addEventListener("click", () => {
  document.getElementById("promptImportFile").value = "";
  document.getElementById("promptImportFile").click();
});

document.getElementById("promptImportFile").addEventListener("change", async (evt) => {
  const f = evt.target.files && evt.target.files[0];
  if (!f) return;

  try {
    const text = await f.text();
    let obj = JSON.parse(text);

    // Tillat b√•de {schemaVersion, promptMaler:[...]} og ren [...]
    let imported = Array.isArray(obj) ? obj : obj.promptMaler;
    const ver = obj?.schemaVersion;

    if (ver && ver !== PROMPT_DB_SCHEMA_VERSION) {
      throw new Error(`Feil schemaVersion i fil: ${ver} (forventer ${PROMPT_DB_SCHEMA_VERSION})`);
    }
    if (!Array.isArray(imported)) throw new Error("Filen inneholder ikke promptMaler[]");

    // Normaliser felter
    imported = imported.map(p => ({
      id: String(p.id || "").trim(),
      hotkey: p.hotkey ?? "",
      type: p.type ?? "",
      beskrivelse: p.beskrivelse ?? "",
      prompt: p.prompt ?? ""
    }));

    pe_validate(imported);

    const overwrite = confirm(
      `Importer prompt-maler:

OK = üö®OVERSKRIV alt som ligger lokalt n√•.
Avbryt = MERGE (importerte erstatter samme id, og nye legges til).`
    );
let next;
    if (overwrite || !Array.isArray(pe_maler)) {
      next = imported;
    } else {
      // merge: behold rekkef√∏lge i eksisterende, erstatt ved id, legg til nye til slutt
      const map = new Map(imported.map(p => [p.id, p]));
      next = pe_maler.map(p => map.has(p.id) ? map.get(p.id) : p);
      const existingIds = new Set(pe_maler.map(p => p.id));
      for (const p of imported) {
        if (!existingIds.has(p.id)) next.push(p);
      }
    }

    await pe_savePrompts(next);
    await pe_openAndLoad();
    pe_setStatus(overwrite ? "Importert (overskrevet)" : "Importert (merge)");
  } catch (e) {
    pe_setStatus("Feil: " + e.message);
    alert("Kunne ikke importere: " + e.message);
  }
});

document.getElementById("promptSearch").addEventListener("input", pe_renderList);

["pe_id", "pe_hotkey", "pe_type", "pe_beskrivelse", "pe_prompt"].forEach(id => {
  document.getElementById(id).addEventListener("input", () => pe_applyFormToSelected());
});

document.addEventListener("keydown", (e) => {
  if (!e.ctrlKey) return;

  const key = e.key; // "1".."9"
  if (key >= "1" && key <= "9") {
    const id = hotkeyMap[key];
    if (id) {
      e.preventDefault();
      velgPromptVedId(id);
    }
  }
});

document.addEventListener("DOMContentLoaded", () => {
  byggPromptDropdown({ beholdValg: true, sorter: false })
    .catch(err => console.error("Dropdown-feil:", err));

  // Statuslinje for malutvalg (vises bare for relevante prompter)
  const promptSel = document.getElementById("promptType");
  const st = document.getElementById("templateSelectionStatus");

  function promptBrukerMaler(promptId){
    return promptId === "malbasert";
  }

  function oppdaterStatusForValgtPrompt(){
    if (!st || !promptSel) return;
    const pid = promptSel.value || "";
    if (promptBrukerMaler(pid)) {
      st.textContent = "Maler velges automatisk ved sending (5‚Äì6 relevante utdrag).";
    } else {
      st.textContent = "";
    }
  }

  if (promptSel) {
    promptSel.addEventListener("change", oppdaterStatusForValgtPrompt);
    // Kj√∏r √©n gang etter at dropdown sannsynligvis er fylt
    setTimeout(oppdaterStatusForValgtPrompt, 250);
  }
});
async function startGPT4oDiktat() {
  nf_resetTranscripts();
document.getElementById("gptDiktatKnapp").disabled = true;
  document.getElementById("gptStoppKnapp").disabled = false;

  try {
    await startRealtimeDictation();
  } catch (e) {
    console.error(e);
    // re-enable UI hvis oppstart feiler
    document.getElementById("gptDiktatKnapp").disabled = false;
    document.getElementById("gptStoppKnapp").disabled = true;
    setDiktatStatus("Kunne ikke starte Realtime: " + (e?.message || e));
  }
}

async function stoppGPT4oDiktat() {
  document.getElementById("gptDiktatKnapp").disabled = false;
  document.getElementById("gptStoppKnapp").disabled = true;

  try {
    await stopRealtimeDictation();
  } catch (e) {
    console.error(e);
    setDiktatStatus("Feil ved stopp: " + (e?.message || e));
  }
}

// failsafe for onclick hvis du bruker module/iframe-scope
window.startGPT4oDiktat = startGPT4oDiktat;
window.stoppGPT4oDiktat = stoppGPT4oDiktat;

// =====================================================
// VAD TUNING UI + RMS-meter + Auto-kalibrering
// =====================================================

const VAD_STORAGE_KEY = "gpt4o_vad_settings_v1";

const vadSettingsDefault = {
  startThreshold: 0.020,
  stopThreshold:  0.015,
  silenceHoldMs:  750,
  minPhraseMs:    1200,
  maxPhraseMs:   8000
};

let vadSettings = loadVadSettings();

// --- UI refs ---
const $ = (id) => document.getElementById(id);

function loadVadSettings() {
  try {
    const raw = localStorage.getItem(VAD_STORAGE_KEY);
    if (!raw) return { ...vadSettingsDefault };
    const obj = JSON.parse(raw);
    return { ...vadSettingsDefault, ...obj };
  } catch {
    return { ...vadSettingsDefault };
  }
}

function saveVadSettings() {
  try {
    localStorage.setItem(VAD_STORAGE_KEY, JSON.stringify(vadSettings));
  } catch {}
}

function fmt3(x) { return Number(x).toFixed(3); }

function syncVadUI() {
  if (!$("slStart")) return; // panel ikke p√• siden

  $("slStart").value = vadSettings.startThreshold;
  $("slStop").value = vadSettings.stopThreshold;
  $("slSilence").value = vadSettings.silenceHoldMs;
  $("slMinPhrase").value = vadSettings.minPhraseMs;
  $("slMaxPhrase").value = vadSettings.maxPhraseMs;

  $("vStart").textContent = fmt3(vadSettings.startThreshold);
  $("vStop").textContent = fmt3(vadSettings.stopThreshold);
  $("vSilence").textContent = `${vadSettings.silenceHoldMs} ms`;
  $("vMinPhrase").textContent = `${vadSettings.minPhraseMs} ms`;
  $("vMaxPhrase").textContent = `${vadSettings.maxPhraseMs} ms`;
}

function clampStopUnderStart() {
  // s√∏rg for hysterese: stop < start
  if (vadSettings.stopThreshold >= vadSettings.startThreshold) {
    vadSettings.stopThreshold = Math.max(0.003, vadSettings.startThreshold - 0.003);
  }
}

// Bind sliders
function bindVadUI() {
  if (!$("slStart")) return;

  const onChange = () => {
    vadSettings.startThreshold = parseFloat($("slStart").value);
    vadSettings.stopThreshold = parseFloat($("slStop").value);
    vadSettings.silenceHoldMs = parseInt($("slSilence").value, 10);
    vadSettings.minPhraseMs   = parseInt($("slMinPhrase").value, 10);
    vadSettings.maxPhraseMs   = parseInt($("slMaxPhrase").value, 10);

    clampStopUnderStart();
    saveVadSettings();
    syncVadUI();
  };

  ["slStart","slStop","slSilence","slMinPhrase","slMaxPhrase"].forEach(id => {
    $(id).addEventListener("input", onChange);
    $(id).addEventListener("change", onChange);
  });

  $("btnVadReset").addEventListener("click", () => {
    vadSettings = { ...vadSettingsDefault };
    saveVadSettings();
    syncVadUI();
    setCalibStatus("Resatt til standard.");
  });

  $("btnVadCalibrate").addEventListener("click", async () => {
    await autoCalibrateNoise();
  });

  syncVadUI();
}

function setCalibStatus(msg) {
  if ($("calibStatus")) $("calibStatus").textContent = msg || "";
}

// -----------------------------------------------------
// RMS-meter: oppdateres fra VAD-loopen
// Kall updateRmsUI(rms) √©n gang per VAD-frame.
// -----------------------------------------------------
function updateRmsUI(rms) {
  if (!$("rmsBar")) return;

  // Map RMS til en bar (ikke vitenskap, bare nyttig)
  const pct = Math.max(0, Math.min(100, (rms / 0.08) * 100));
  $("rmsBar").style.width = pct.toFixed(1) + "%";
  $("rmsVal").textContent = rms.toFixed(3);
}

// -----------------------------------------------------
// Auto-kalibrering: m√•ler st√∏y i 1.5 sek og setter terskler
// Krever at mik er aktiv (gptStream + analyser finnes)
// -----------------------------------------------------
async function autoCalibrateNoise() {
  // analyser er variabelen din i VAD-koden. Hvis du heter noe annet, endre her:
  if (!window.analyser && typeof analyser === "undefined") {
    setCalibStatus("Start GPT-4o diktat f√∏rst (mikrofon m√• v√¶re aktiv), s√• kalibrer.");
    return;
  }

  const useAnalyser = (typeof analyser !== "undefined") ? analyser : window.analyser;
  if (!useAnalyser) {
    setCalibStatus("Start GPT-4o diktat f√∏rst (mikrofon m√• v√¶re aktiv), s√• kalibrer.");
    return;
  }

  setCalibStatus("Kalibrerer‚Ä¶ v√¶r stille i 1‚Äì2 sek.");

  const buf = new Uint8Array(useAnalyser.fftSize);
  const samples = [];
  const tStart = performance.now();
  const DURATION_MS = 1500;

  while (performance.now() - tStart < DURATION_MS) {
    useAnalyser.getByteTimeDomainData(buf);

    let sum = 0;
    for (let i = 0; i < buf.length; i++) {
      const v = (buf[i] - 128) / 128;
      sum += v * v;
    }
    const rms = Math.sqrt(sum / buf.length);
    samples.push(rms);

    await new Promise(r => setTimeout(r, 60));
  }

  // robust: bruk 90-persentil av st√∏yen (t√•ler sm√• klikk)
  samples.sort((a,b) => a-b);
  const p90 = samples[Math.floor(samples.length * 0.90)] || 0.01;

  // Sett terskler relativt til st√∏y
  // (kan justeres; dette fungerer ofte bra)
  const newStop = Math.min(0.070, Math.max(0.006, p90 * 2.2));
  const newStart = Math.min(0.080, Math.max(newStop + 0.003, p90 * 3.0));

  vadSettings.stopThreshold = parseFloat(newStop.toFixed(3));
  vadSettings.startThreshold = parseFloat(newStart.toFixed(3));
  saveVadSettings();
  syncVadUI();

  setCalibStatus(`Kalibrert. St√∏y p90=${p90.toFixed(3)} ‚Üí stop=${vadSettings.stopThreshold.toFixed(3)}, start=${vadSettings.startThreshold.toFixed(3)}`);
}

// Kj√∏r binding n√•r DOM er klar
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", bindVadUI);
} else {
  bindVadUI();
}

const VAD_UI_STORAGE_KEY = "gpt4o_vad_ui_collapsed_v1";

function setVadTuningCollapsed(collapsed) {
  const body = document.getElementById("vadTuningBody");
  const chev = document.getElementById("vadTuningChevron");
  if (!body || !chev) return;

  body.style.display = collapsed ? "none" : "block";
  chev.textContent = collapsed ? "‚ñ∏" : "‚ñæ";

  try {
    localStorage.setItem(VAD_UI_STORAGE_KEY, collapsed ? "1" : "0");
  } catch {}
}

function initVadTuningCollapse() {
  const header = document.getElementById("vadTuningHeader");
  if (!header) return;

  // Default = kollapset (true) hvis ikke lagret
  let collapsed = true;
  try {
    const raw = localStorage.getItem(VAD_UI_STORAGE_KEY);
    if (raw === "0") collapsed = false;
    if (raw === "1") collapsed = true;
  } catch {}

  setVadTuningCollapsed(collapsed);

  header.addEventListener("click", () => {
    const body = document.getElementById("vadTuningBody");
    const isCollapsedNow = !body || body.style.display === "none";
    setVadTuningCollapsed(!isCollapsedNow);
  });
}

// Kj√∏r n√•r DOM er klar (kan ligge sammen med bindVadUI)
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initVadTuningCollapse);
} else {
  initVadTuningCollapse();
}


    
/* =========================
   TemplateDB (localStorage)
   ========================= */
const TEMPLATE_DB_KEY = "templateBank_v1";
const TEMPLATE_DB_SCHEMA_VERSION = 1;

let tplCurrentId = null;

function loadTemplateDB() {
  try {
    const raw = localStorage.getItem(TEMPLATE_DB_KEY);
    if (!raw) return { schemaVersion: TEMPLATE_DB_SCHEMA_VERSION, templates: [] };
    const obj = JSON.parse(raw);
    if (!obj || typeof obj !== "object") throw new Error("Ugyldig DB-format");
    if (!obj.schemaVersion) obj.schemaVersion = TEMPLATE_DB_SCHEMA_VERSION;
    if (!Array.isArray(obj.templates)) obj.templates = [];
    return obj;
  } catch (e) {
    console.warn("Kunne ikke lese TemplateDB:", e);
    return { schemaVersion: TEMPLATE_DB_SCHEMA_VERSION, templates: [] };
  }
}

function saveTemplateDB(db) {
  localStorage.setItem(TEMPLATE_DB_KEY, JSON.stringify(db));
}

function nowIso() {
  return new Date().toISOString();
}

function makeId() {
  return "tpl_" + Math.random().toString(36).slice(2, 10) + "_" + Date.now().toString(36);
}



/* =========================
   Relevansmotor for malbank
   (brukes av enkelte prompter)
   ========================= */

// NOTE: Dette er en bevisst enkel, lokal heuristikk. Den er laget slik at vi senere
// kan bytte ut/forbedre logikken (keyword-regler, tags, scoring, embedding, osv.)
// uten √• endre lagringsformatet.

function _norm(s) {
  return (s || "")
    .toLowerCase()
    .replace(/[^√Ä-…è\p{L}\p{N}]+/gu, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function _tokens(normText) {
  if (!normText) return [];
  return normText.split(" ").filter(Boolean);
}

function getAllTemplates() {
  const db = loadTemplateDB();
  return Array.isArray(db.templates) ? db.templates : [];
}

function fallbackTemplates(all, cfg = {}) {
  // Brukes n√•r ingen maler f√•r nok score, men vi likevel √∏nsker √• sende med et lite "bibliotek"
  // for at GPT skal ha noe √• st√∏tte seg p√•.
  const {
    maxTemplates = 4,
    maxCharsPerTemplate = 2000,
    maxTotalChars = 9000
  } = cfg;

  // Sorter p√• updatedAt/createdAt hvis mulig, ellers behold rekkef√∏lge
  const sorted = [...all].sort((a, b) => {
    const ta = Date.parse(a.updatedAt || a.createdAt || "") || 0;
    const tb = Date.parse(b.updatedAt || b.createdAt || "") || 0;
    return tb - ta;
  });

  const picked = [];
  let total = 0;
  for (const tpl of sorted) {
    if (picked.length >= maxTemplates) break;
    const content = (tpl.content || "").toString();
    const clipped = content.length > maxCharsPerTemplate
      ? content.slice(0, maxCharsPerTemplate) + "\n‚Ä¶(avkortet)"
      : content;
    const cost = (tpl.title || "").length + clipped.length + 50;
    if (total + cost > maxTotalChars) break;
    picked.push({
      id: tpl.id || null,
      title: tpl.title || "(Uten tittel)",
      content: clipped,
      score: 0
    });
    total += cost;
  }
  return picked;
}


function scoreTemplate(tpl, inputNorm, inputTokens, cfg) {
  const titleNorm = _norm(tpl.title || "");
  const keywordsNorm = _norm(Array.isArray(tpl.keywords) ? tpl.keywords.join(" ") : (tpl.keywords || ""));
  const contentHeadNorm = _norm((tpl.content || "").slice(0, 800)); // ytelse
  let score = 0;

  for (const tok of inputTokens) {
    if (tok.length < 4) continue;
    if (titleNorm.includes(tok)) score += 2.5;
    else if (keywordsNorm && keywordsNorm.includes(tok)) score += 2.0;
    else if (contentHeadNorm.includes(tok)) score += 1.0;
  }

  const boosts = (cfg && Array.isArray(cfg.keywordsBoost)) ? cfg.keywordsBoost : [];
  for (const b of boosts) {
    const bn = _norm(b);
    if (bn && inputNorm.includes(bn)) score += 1.5;
  }

  if ((tpl.title || "").length > 0 && (tpl.title || "").length <= 32) score += 0.2;
  return score;
}

function selectRelevantTemplates(inputText, cfg = {}) {
  const {
    maxTemplates = 6,
    minScore = 2.0,
    maxCharsPerTemplate = 2500,
    maxTotalChars = 12000
  } = cfg;

  const all = getAllTemplates();
  if (!all.length) return [];

  const inputNorm = _norm(inputText);
  const inputTokens = _tokens(inputNorm);

  if (inputTokens.length < 4) return [];

  const scored = all
    .map(tpl => ({ tpl, score: scoreTemplate(tpl, inputNorm, inputTokens, cfg) }))
    .filter(x => x.score >= minScore)
    .sort((a,b) => b.score - a.score);

  const picked = [];
  let total = 0;

  for (const { tpl, score } of scored) {
    if (picked.length >= maxTemplates) break;

    const content = (tpl.content || "").toString();
    const clipped = content.length > maxCharsPerTemplate
      ? content.slice(0, maxCharsPerTemplate) + "\n‚Ä¶(avkortet)"
      : content;

    const cost = (tpl.title || "").length + clipped.length + 60;
    if (total + cost > maxTotalChars) break;

    picked.push({
      id: tpl.id || null,
      title: tpl.title || "(Uten tittel)",
      content: clipped,
      score: Number(score.toFixed(2))
    });
    total += cost;
  }

  return picked;
}

function renderTemplatesAttachment(selected, heading) {
  if (!selected || !selected.length) return "";
  const lines = [];
  lines.push(heading || "VEDLEGG: Relevante maler (lokal malbank)");
  for (const t of selected) {
    lines.push(`\n---\nMAL: ${t.title}${t.id ? ` (id: ${t.id})` : ""}\n${t.content}`);
  }
  return lines.join("\n");
}

function getTemplateSelectConfigForPrompt(promptId) {
  // Kun de innebygde promptene som *skal* f√• med maler
  // (malbasert utfylling)
  if (promptId === "malbasert") {
    return {
      maxTemplates: 6,
      minScore: 2.0,
      maxCharsPerTemplate: 2200,
      maxTotalChars: 11000,
      keywordsBoost: ["mal", "utfyll", "notat", "standard", "status", "plan", "oppsummering"]
    };
  }
return null;
}

/* ---- Modal: Template Editor ---- */
function openTemplateEditor() {
  document.getElementById("templateEditorModal").style.display = "flex";
  // select first template if none selected
  const db = loadTemplateDB();
  if (!tplCurrentId && db.templates.length) tplCurrentId = db.templates[0].id;
  renderTemplateList();
  loadTemplateIntoEditor(tplCurrentId);
}

function closeTemplateEditor() {
  document.getElementById("templateEditorModal").style.display = "none";
  document.getElementById("tplStatus").textContent = "";
}

function renderTemplateList() {
  const db = loadTemplateDB();
  const q = (document.getElementById("tplSearch").value || "").trim().toLowerCase();
  const list = document.getElementById("tplList");
  list.innerHTML = "";

  const filtered = db.templates
    .slice()
    .sort((a,b) => (b.updatedAt || "").localeCompare(a.updatedAt || ""))
    .filter(t => {
      if (!q) return true;
      const hay = (t.title || "") + "\n" + (t.content || "");
      return hay.toLowerCase().includes(q);
    });

  if (!filtered.length) {
    const empty = document.createElement("div");
    empty.style.color = "#666";
    empty.style.fontSize = "14px";
    empty.textContent = q ? "Ingen treff." : "Ingen maler enda. Trykk ‚ÄúNy mal‚Äù.";
    list.appendChild(empty);
    return;
  }

  filtered.forEach(t => {
    const item = document.createElement("div");
    item.className = "tpl-item" + (t.id === tplCurrentId ? " active" : "");
    item.onclick = () => {
      tplCurrentId = t.id;
      renderTemplateList();
      loadTemplateIntoEditor(tplCurrentId);
    };

    const title = document.createElement("div");
    title.className = "tpl-title";
    title.textContent = t.title || "(Uten tittel)";

    const meta = document.createElement("div");
    meta.className = "tpl-meta";
    const updated = t.updatedAt ? new Date(t.updatedAt).toLocaleString() : "";
    const chars = (t.content || "").length;
    meta.textContent = `${updated}${updated ? " ‚Ä¢ " : ""}${chars} tegn`;

    item.appendChild(title);
    item.appendChild(meta);
    list.appendChild(item);
  });
}

function loadTemplateIntoEditor(id) {
  const titleEl = document.getElementById("tplTitle");
  const keywordsEl = document.getElementById("tplKeywords");
  const contentEl = document.getElementById("tplContent");
  const statusEl = document.getElementById("tplStatus");

  if (!id) {
    titleEl.value = "";
    if (keywordsEl) keywordsEl.value = "";
    contentEl.value = "";
    statusEl.textContent = "";
    return;
  }

  const db = loadTemplateDB();
  const t = db.templates.find(x => x.id === id);
  if (!t) {
    titleEl.value = "";
    if (keywordsEl) keywordsEl.value = "";
    contentEl.value = "";
    statusEl.textContent = "";
    return;
  }

  titleEl.value = t.title || "";
  if (keywordsEl) {
    const kws = Array.isArray(t.keywords) ? t.keywords : (typeof t.keywords === "string" ? t.keywords.split(",") : []);
    keywordsEl.value = (kws || []).map(s => (s||"").trim()).filter(Boolean).join(", ");
  }
  contentEl.value = t.content || "";
  statusEl.textContent = "";
}

function newTemplate() {
  const db = loadTemplateDB();
  const id = makeId();
  const t = { id, title: "Ny mal", content: "", createdAt: nowIso(), updatedAt: nowIso() };
  db.templates.unshift(t);
  saveTemplateDB(db);
  tplCurrentId = id;
  renderTemplateList();
  loadTemplateIntoEditor(id);
  document.getElementById("tplTitle").focus();
  document.getElementById("tplTitle").select();
}

function saveTemplateFromEditor() {
  const title = (document.getElementById("tplTitle").value || "").trim();
  const content = (document.getElementById("tplContent").value || "").trim();
  const keywordsRaw = (document.getElementById("tplKeywords")?.value || "").trim();
  const keywords = keywordsRaw ? keywordsRaw.split(",").map(s => s.trim()).filter(Boolean) : [];
  const statusEl = document.getElementById("tplStatus");

  if (!title && !content) {
    statusEl.textContent = "Ingenting √• lagre.";
    return;
  }

  const db = loadTemplateDB();
  let t = db.templates.find(x => x.id === tplCurrentId);

  if (!t) {
    // if somehow no current, create new
    const id = makeId();
    t = { id, createdAt: nowIso() };
    db.templates.unshift(t);
    tplCurrentId = id;
  }

  t.title = title || "(Uten tittel)";
  t.keywords = keywords;
  t.content = content || "";
  t.updatedAt = nowIso();

  saveTemplateDB(db);
  statusEl.textContent = "Lagret.";
  renderTemplateList();
}

function deleteCurrentTemplate() {
  if (!tplCurrentId) return;
  if (!confirm("Slette denne malen?")) return;

  const db = loadTemplateDB();
  const idx = db.templates.findIndex(x => x.id === tplCurrentId);
  if (idx >= 0) db.templates.splice(idx, 1);
  saveTemplateDB(db);

  tplCurrentId = db.templates.length ? db.templates[0].id : null;
  renderTemplateList();
  loadTemplateIntoEditor(tplCurrentId);
  document.getElementById("tplStatus").textContent = "Slettet.";
}

function exportTemplates() {
  const db = loadTemplateDB();
  const payload = {
    schemaVersion: TEMPLATE_DB_SCHEMA_VERSION,
    exportedAt: nowIso(),
    templates: db.templates || []
  };

  const data = JSON.stringify(payload, null, 2);
  const blob = new Blob([data], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "malbank.json";
  a.click();

  URL.revokeObjectURL(url);
}

function importTemplates(evt) {
  const file = evt?.target?.files?.[0];
  if (!file) return;

  const statusEl = document.getElementById("tplStatus");
  if (statusEl) statusEl.textContent = "Leser fil...";

  const reader = new FileReader();
  reader.onload = () => {
    try {
      const imported = JSON.parse(reader.result);

      if (!imported || typeof imported !== "object") throw new Error("Ugyldig JSON");
      if (!Array.isArray(imported.templates)) throw new Error("Mangler templates[]");

      // schemaVersion er anbefalt. Hvis den finnes og ikke matcher ‚Üí stopp.
      const ver = imported.schemaVersion ?? imported.version ?? null;
      if (ver !== null && Number(ver) !== TEMPLATE_DB_SCHEMA_VERSION) {
        throw new Error(`Feil schemaVersion (${ver}). Forventer ${TEMPLATE_DB_SCHEMA_VERSION}.`);
      }

      // OK = ‚ö†Ô∏èoverskriv, Avbryt = ‚úÖmerge
      const overwrite = confirm(`Import malbank?

OK = OVERSKRIV eksisterende malbank
Avbryt = SL√Ö SAMMEN (merge) med eksisterende`);

      const db = loadTemplateDB();
      const normalized = [];
      const seen = new Set();

      // normaliser + s√∏rg for unike ID-er
      (imported.templates || []).forEach(t => {
        let id = (t && typeof t === "object" && t.id) ? String(t.id).trim() : "";
        if (!id || seen.has(id)) id = makeId();
        seen.add(id);

        normalized.push({
          id,
          title: (t?.title || "").toString().trim() || "(Uten tittel)",
          content: (t?.content || "").toString(),
          createdAt: t?.createdAt || nowIso(),
          updatedAt: nowIso()
        });
      });

      if (overwrite) {
        db.templates = normalized;
      } else {
        // merge by id
        const byId = new Map((db.templates || []).map(t => [t.id, t]));
        normalized.forEach(t => byId.set(t.id, t));
        db.templates = Array.from(byId.values());
      }

      // sort newest first
      db.schemaVersion = TEMPLATE_DB_SCHEMA_VERSION;
      db.templates = (db.templates || []).sort((a,b) => (b.updatedAt || "").localeCompare(a.updatedAt || ""));
      saveTemplateDB(db);

      tplCurrentId = db.templates.length ? db.templates[0].id : null;
      renderTemplateList();
      loadTemplateIntoEditor(tplCurrentId);

      if (statusEl) statusEl.textContent = overwrite ? "Importert (overskrev eksisterende)." : "Importert (sammensl√•tt).";
    } catch (e) {
      console.error("Import-feil:", e);
      alert("Kunne ikke importere: " + (e?.message || e));
      if (statusEl) statusEl.textContent = "Import-feil.";
    } finally {
      evt.target.value = "";
    }
  };
  reader.readAsText(file);
}

/* ---- Modal: Save GPT result as template ---- */
function openSaveAsTemplateModal() {
  const el = document.getElementById("resultatTekst");
  const txt = (el?.innerText || el?.textContent || "").trim();

  if (!txt) {
    alert("Ingen GPT-tekst √• lagre (resultatfeltet er tomt).");
    return;
  }

  document.getElementById("saveAsTemplateModal").style.display = "flex";

  // tittel: f√∏rste ikke-tomme linje / setning
  const firstLine = (txt.split('\n').find(l => l.trim()) || 'Ny mal').trim();
  document.getElementById("satTitle").value = firstLine.slice(0, 60) || "Ny mal";
  const satKw = document.getElementById("satKeywords");
  if (satKw) satKw.value = "";
  document.getElementById("satContent").value = txt;
  document.getElementById("satStatus").textContent = "";
  document.getElementById("satTitle").focus();
  document.getElementById("satTitle").select();
}

function closeSaveAsTemplateModal() {
  document.getElementById("saveAsTemplateModal").style.display = "none";
  document.getElementById("satStatus").textContent = "";
}

function confirmSaveAsTemplate() {
  const title = (document.getElementById("satTitle").value || "").trim();
  const content = (document.getElementById("satContent").value || "").trim();
  const keywordsRaw = (document.getElementById("satKeywords")?.value || "").trim();
  const keywords = keywordsRaw ? keywordsRaw.split(",").map(s => s.trim()).filter(Boolean) : [];
  const statusEl = document.getElementById("satStatus");

  if (!content) {
    statusEl.textContent = "Innhold kan ikke v√¶re tomt.";
    return;
  }

  const db = loadTemplateDB();
  const id = makeId();
  db.templates.unshift({
    id,
    title: title || "(Uten tittel)",
    keywords,
    content,
    createdAt: nowIso(),
    updatedAt: nowIso()
  });
  saveTemplateDB(db);

  statusEl.textContent = "Lagret i malbanken.";

  // refresh list if editor open
  try { renderTemplateList(); } catch(e) {}

  // lukk modal etter kort tid (oppleves ryddig)
  setTimeout(() => {
    try { closeSaveAsTemplateModal(); } catch(e) {}
  }, 350);
}

// ================================
// Push-to-talk (PTT) for /api/transcribe
// Hold button -> record, release -> transcribe + append text
// ================================

(function setupPTT() {
  const btn = document.getElementById("btnPTT");
  const statusEl = document.getElementById("diktatStatus");
  if (!btn) return;

  // --- state
  let stream = null;
  let recorder = null;
  let chunks = [];
  let isRecording = false;
  let isSending = false;
  let startedAt = 0;

async function onDown_guarded(e) {
  e.preventDefault?.();
  await requirePro(async () => {
    onDown(e);
  }, "Push-to-talk er Pro i denne fasen.");
}


  // Prefer pointer events (works for mouse+touch+pen)
 btn.addEventListener("pointerdown", onDown_guarded);
  btn.addEventListener("pointerup", onUp);
  btn.addEventListener("pointercancel", onCancel);
  btn.addEventListener("lostpointercapture", onCancel);

  // Safety: stop if window loses focus
  window.addEventListener("blur", () => { if (isRecording) stopRecording(); });

  // Safety: ESC stops
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && isRecording) stopRecording();
  });

  // Optional: Spacebar push-to-talk when NOT typing in an input/textarea
  // Uncomment if you want:
  /*
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space" && !isTypingContext(e.target) && !e.repeat) {
      e.preventDefault();
      if (!isRecording) startRecording();
    }
  });
  window.addEventListener("keyup", (e) => {
    if (e.code === "Space" && !isTypingContext(e.target)) {
      e.preventDefault();
      if (isRecording) stopRecording();
    }
  });
  */

 const BASE_STATUS = "Klar for diktat";

function setStatus(t) {
  if (!statusEl) return;
  statusEl.textContent = t && t.trim() ? t : BASE_STATUS;
}


  function isTypingContext(el) {
    if (!el) return false;
    const tag = (el.tagName || "").toLowerCase();
    return tag === "input" || tag === "textarea" || el.isContentEditable;
  }

  async function onDown(e) {
    // avoid focus stealing / text selection on long-press
    e.preventDefault();

    if (isSending) return;       // don't start a new recording while sending
    if (isRecording) return;

    // capture pointer so we get pointerup even if user drags off button
    try { btn.setPointerCapture(e.pointerId); } catch (_) {}

    await startRecording();
  }

  function onUp(e) {
    e.preventDefault();
    if (isRecording) stopRecording();
  }

  function onCancel() {
    if (isRecording) stopRecording();
  }

  async function startRecording() {
    isRecording = true;
    chunks = [];
    startedAt = Date.now();
    btn.classList.add("ptt-on");
    btn.disabled = false; // keep clickable
    setStatus("Lytter‚Ä¶ (slipp for √• sende)");

    try {
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      const options = pickRecorderOptions();
      recorder = new MediaRecorder(stream, options);

      recorder.ondataavailable = (ev) => {
        if (ev.data && ev.data.size > 0) chunks.push(ev.data);
      };

      recorder.onerror = (ev) => {
        console.error("PTT MediaRecorder error:", ev);
      };

      recorder.onstop = async () => {
        try {
          btn.classList.remove("ptt-on");
          if (!chunks.length) {
            setStatus("");
            cleanup();
            return;
          }

          // Avoid sending ultra-short accidental taps (< ~200ms)
          const durMs = Date.now() - startedAt;
          if (durMs < 200) {
            setStatus("");
            cleanup();
            return;
          }

          isSending = true;
          setStatus("Sender til transkribering‚Ä¶");

          const blob = new Blob(chunks, { type: recorder.mimeType || "audio/webm" });

          const text = await sendToTranscribe(blob);

          if (text && text.trim()) {
            appendTextToDiktat(text.trim());
          }

          setStatus("");
        } catch (err) {
          console.error(err);
          setStatus("Feil ved transkribering");
          alert(err?.message || "Feil ved transkribering");
        } finally {
          isSending = false;
          cleanup();
        }
      };

      recorder.start(); // no timeslice -> single blob at end
    } catch (err) {
      console.error(err);
      isRecording = false;
      btn.classList.remove("ptt-on");
      setStatus("Mikrofon ikke tilgjengelig");
      alert("Kunne ikke starte mikrofon. Sjekk tillatelser.");
      cleanup();
    }
  }

  function stopRecording() {
    if (!isRecording) return;
    isRecording = false;
    setStatus("Stopper‚Ä¶");

    try {
      if (recorder && recorder.state !== "inactive") recorder.stop();
      else {
        btn.classList.remove("ptt-on");
        setStatus("");
        cleanup();
      }
    } catch (e) {
      btn.classList.remove("ptt-on");
      setStatus("");
      cleanup();
    }
  }

  function cleanup() {
    try {
      if (stream) stream.getTracks().forEach(t => t.stop());
    } catch (_) {}
    stream = null;
    recorder = null;
    chunks = [];
    startedAt = 0;
    isRecording = false;
    btn.classList.remove("ptt-on");
  }
  // Eksponer PTT-kontroll for hurtigtaster (Ctrl+P hold inne)
  window.pttStart = () => { if (!isSending && !isRecording) startRecording(); };
  window.pttStop  = () => { if (isRecording) stopRecording(); };

  function pickRecorderOptions() {
    // Choose best supported format (Opus in WebM is ideal)
    const opt = {};
    if (window.MediaRecorder) {
      if (MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) {
        opt.mimeType = "audio/webm;codecs=opus";
      } else if (MediaRecorder.isTypeSupported("audio/webm")) {
        opt.mimeType = "audio/webm";
      } else if (MediaRecorder.isTypeSupported("audio/mp4")) {
        opt.mimeType = "audio/mp4";
      }
    }
    return opt;
  }

async function sendToTranscribe(blob) {
  const fd = new FormData();
  fd.append("audio", blob, "ptt.webm"); // üëà backend krever "audio"
 fd.append("language", "nb"); // üëà Norsk bokm√•l

 const res = await apiFetchAuthed("/api/transcribe", {
  method: "POST",
  body: fd
});


  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`Transcribe-feil: ${res.status}${txt ? " ‚Äì " + txt : ""}`);
  }

  const data = await res.json().catch(() => ({}));
  return data.text || data.transcript || data.result || "";
}


  function appendTextToDiktat(text) {
    // üîß Tilpass denne til ditt faktiske tekstfelt:
    // Jeg gjetter p√• "diktatTekst" siden du bruker det andre steder.
    const ta =
      document.getElementById("diktatTekst") ||
      document.getElementById("inputText") ||
      document.querySelector("textarea");

    if (!ta) return;

    const needsSpace = ta.value && !ta.value.endsWith("\n") && !ta.value.endsWith(" ");
    ta.value = ta.value + (needsSpace ? " " : "") + text;
    ta.focus();
  }
})();

document.addEventListener("DOMContentLoaded", () => {
  const btnOpen = document.getElementById("btnHelpModal");
  const modal = document.getElementById("helpModal");
  const btnClose = document.getElementById("btnHelpClose");

  if (!btnOpen || !modal || !btnClose) {
    console.warn("Help modal wiring missing:", { btnOpen, modal, btnClose });
    return;
  }

  function openModal(){
    modal.style.display = "flex";
    modal.setAttribute("aria-hidden", "false");
    document.body.style.overflow = "hidden";
    btnClose.focus();
  }

  function closeModal(){
    modal.style.display = "none";
    modal.setAttribute("aria-hidden", "true");
    document.body.style.overflow = "";
    btnOpen.focus();
  }

  btnOpen.addEventListener("click", openModal);
  btnClose.addEventListener("click", closeModal);

  modal.addEventListener("click", (e) => {
    if (e.target === modal) closeModal();
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && modal.style.display !== "none") closeModal();
  });

  // (valgfritt) hvis du vil √•pne modalen fra andre steder
  window.openHelpModal = openModal;
  window.closeHelpModal = closeModal;
});






        // ================================
        // Anonymisering ‚Äì modal + UI helpers
        // ================================
        function openPrivacySettingsModal() {
          const modal = document.getElementById("privacySettingsModal");
          if (!modal) return;
          const ps = loadPrivacySettings();

          const chk = document.getElementById("chkAutoAnonymize");
          const sel = document.getElementById("selAnonymMode");

          if (chk) chk.checked = !!ps.autoAnonymize;
          if (sel) sel.value = ps.mode || "hybrid";

          // reset preview
          const box = document.getElementById("privacyPreviewBox");
          if (box) box.style.display = "none";

          updateLastAnonymizedUI();
          modal.style.display = "block";
        }

        function closePrivacySettingsModal() {
          const modal = document.getElementById("privacySettingsModal");
          if (!modal) return;
          modal.style.display = "none";
          // reset preview
          const box = document.getElementById("privacyPreviewBox");
          if (box) box.style.display = "none";
        }

        // Klikk utenfor kortet for √• lukke
        document.addEventListener("click", (e) => {
          const modal = document.getElementById("privacySettingsModal");
          if (!modal || modal.style.display === "none") return;
          if (e.target === modal) closePrivacySettingsModal();
        });

        // Persist settings on change
        document.addEventListener("change", (e) => {
          if (!e || !e.target) return;
          if (e.target.id === "chkAutoAnonymize" || e.target.id === "selAnonymMode") {
            const ps = loadPrivacySettings();
            if (e.target.id === "chkAutoAnonymize") ps.autoAnonymize = !!e.target.checked;
            if (e.target.id === "selAnonymMode") ps.mode = String(e.target.value || "hybrid");
            savePrivacySettings(ps);
            updateLastAnonymizedUI(); // oppdater tekst som viser modus
          }
        });

        function updateLastAnonymizedUI() {
          const payload = loadLastAnonymized();
          const ul = document.getElementById("lastAnonymizedList");
          const summary = document.getElementById("lastAnonymizedSummary");
          if (!ul || !summary) return;

          ul.innerHTML = "";
          const items = (payload && payload.items) ? payload.items : [];
          const stats = (payload && payload.stats) ? payload.stats : {};
          const mode  = payload.mode || (loadPrivacySettings().mode || "hybrid");

          const total = items.length || 0;
          const parts = Object.keys(stats || {}).sort().map(k => `${k}: ${stats[k]}`);
          summary.textContent = total
            ? `Modus: ${mode}. Totalt maskert: ${total}. ` + (parts.length ? `(${parts.join(", ")})` : "")
            : `Ingen registrerte funn enn√•.`;

          // Vis maks 250 for √• unng√• tung DOM
          const max = Math.min(items.length, 250);
          for (let i = 0; i < max; i++) {
            const it = items[i];
            const li = document.createElement("li");
            li.textContent = `${it.type}: "${it.value}"`;
            ul.appendChild(li);
          }
          if (items.length > max) {
            const li = document.createElement("li");
            li.textContent = `‚Ä¶ +${items.length - max} flere`;
            ul.appendChild(li);
          }
        }

        function clearLastAnonymized() {
          saveLastAnonymized({ items: [], stats: {} });
          updateLastAnonymizedUI();
        }

        function runAnonymizePreview() {
          const diktatTekst = document.getElementById("diktatTekst");
          const box = document.getElementById("privacyPreviewBox");
          const ta = document.getElementById("privacyPreviewText");
          if (!diktatTekst || !box || !ta) return;

          const ps = loadPrivacySettings();
          const mode = ps.mode || "hybrid";
          const res = anonymizeText(diktatTekst.value || "", mode);

          ta.value = res.text;
          box.style.display = "block";

          // lagre ogs√• listen, siden det er nyttig
          saveLastAnonymized({ items: res.items, stats: res.stats, mode, at: Date.now() });
          updateLastAnonymizedUI();
        }



// Bind fane-klikk (t√•ler at dette kj√∏res f√∏r elementene finnes)
document.addEventListener("DOMContentLoaded", () => {
  const rtBtn = document.getElementById("tabRealtime");
  const ffBtn = document.getElementById("tabFullfile");
  if (rtBtn) rtBtn.addEventListener("click", () => nf_setTab("rt"));
  if (ffBtn) ffBtn.addEventListener("click", () => nf_setTab("full"));
  const runBtn = document.getElementById("btnRunFullfile");
  if (runBtn) runBtn.addEventListener("click", async () => {
    if (!nf_fullBlobStored) return;
    setDiktatStatus("Fullfil: sender ‚Ä¶");
    try{
      await nf_transcribeFullBlob(nf_fullBlobStored);
      setDiktatStatus("Fullfil: ferdig.");
      nf_setTab("full");
    }catch(e){
      console.warn(e);
      setDiktatStatus("Fullfil-feil: " + (e?.message || e));
    }
  });
});

</script>

<!-- Supabase client (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
/* ====== KONFIG (FYLL INN) ====== */
const SUPABASE_URL = "https://rmwoihyzsrsokeflijzk.supabase.co";      // <-- Project URL
const SUPABASE_PUBLISHABLE_KEY = "sb_publishable_6vgfDwOPkSWlyMLUMfvNUA_O2U726Jz";          // <-- Publishable key

/* Cloudflare Pages URL (redirect). window.location.origin fungerer fint her. */
const APP_BASE_URL = window.location.origin;

/* ====== INIT ====== */
const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

/* ====== Robust auth helpers (timeout + redirect session) ====== */
function withTimeout(promise, ms = 15000){
  return Promise.race([
    promise,
    new Promise((_, rej)=> setTimeout(()=>rej(new Error("timeout")), ms))
  ]);
}

// H√•ndter Supabase redirect (recovery/confirm) der tokens/code kommer i URL
async function handleSupabaseAuthRedirect(){
  try{
    const url = new URL(window.location.href);

    // PKCE / code-flow (kan komme som ?code=...)
    const code = url.searchParams.get("code");
    if(code){
      const { error } = await supabaseClient.auth.exchangeCodeForSession(code);
      if(error) console.warn("exchangeCodeForSession error:", error);
      url.searchParams.delete("code");
      try{
        history.replaceState(null, "", url.pathname + (url.searchParams.toString()?`?${url.searchParams}`:"") + (url.hash||""));
      }catch(e){}
    }

    // Hash-flow (#access_token=...&refresh_token=...&type=recovery)
    const rawHash = (url.hash || "").replace(/^#/, "");
    const hp = new URLSearchParams(rawHash);
    const access_token = hp.get("access_token");
    const refresh_token = hp.get("refresh_token");
    const type = hp.get("type");

    if(access_token && refresh_token){
      const { error } = await supabaseClient.auth.setSession({ access_token, refresh_token });
      if(error) console.warn("setSession error:", error);

      // Rydd vekk hash etter at session er satt
      try{ history.replaceState(null, "", url.pathname + (url.search || "")); }catch(e){}
    }

    if(type === "recovery"){
      inRecoveryFlow = true;
      try{ openAuthModal(); }catch(e){}
      try{ if(typeof enableRecoveryUI === "function") enableRecoveryUI(true); }catch(e){}
    }
  }catch(e){
    console.warn("handleSupabaseAuthRedirect failed:", e);
  }
}

// Kj√∏r tidlig ved oppstart
handleSupabaseAuthRedirect();

// ===== Hard reset auth (rydder lokal Supabase-state) =====
async function hardResetAuth(){
  // 1) Fors√∏k √• logge ut "ordentlig"
  try{ await supabaseClient.auth.signOut({ scope: "global" }); }catch(e){}
  try{ await supabaseClient.auth.signOut(); }catch(e){}

  // 2) Fjern Supabase-relatert lagring
  try{
    for(const k of Object.keys(localStorage)){
      if(k.includes("supabase") || k.includes("sb-") || k.includes("auth-token")) localStorage.removeItem(k);
    }
  }catch(e){}
  try{
    for(const k of Object.keys(sessionStorage)){
      if(k.includes("supabase") || k.includes("sb-") || k.includes("auth-token")) sessionStorage.removeItem(k);
    }
  }catch(e){}

  // 3) Slett cookies p√• domenet (best effort)
  try{
    const cookies = document.cookie.split(";") || [];
    for(const c of cookies){
      const eqPos = c.indexOf("=");
      const name = (eqPos > -1 ? c.substr(0, eqPos) : c).trim();
      if(name){
        document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/";
      }
    }
  }catch(e){}

  // 4) T√∏m Cache Storage (PWA/asset-cache)
  try{
    if("caches" in window){
      const keys = await caches.keys();
      await Promise.all(keys.map(k=>caches.delete(k)));
    }
  }catch(e){}

  // 5) Slett IndexedDB (noen nettlesere/SDKer kan bruke dette)
  try{
    if(window.indexedDB && indexedDB.databases){
      const dbs = await indexedDB.databases();
      await Promise.all((dbs||[]).map(db => db && db.name ? new Promise(res=>{
        const req = indexedDB.deleteDatabase(db.name);
        req.onsuccess = req.onerror = req.onblocked = ()=>res();
      }) : Promise.resolve()));
    }
  }catch(e){}

  // 6) Fjern hash/query som kan trigge recovery/verify-modus
  try{ history.replaceState(null, "", window.location.pathname); }catch(e){}

  // 7) Full reload for √• starte med "blankt ark"
  location.reload(true);
}


let pendingAction = null; // brukes for √• kj√∏re en handling etter login
let inRecoveryFlow = false; // settes n√•r Supabase sender oss tilbake for passord-reset

/* ====== UI refs ====== */
const authPill   = document.getElementById("authPill");
const btnLogin   = document.getElementById("btnLogin");
const btnUpgrade = document.getElementById("btnUpgrade");
const btnLogout  = document.getElementById("btnLogout");

const authModal  = document.getElementById("authModal");
const authClose  = document.getElementById("authClose");
const authEmail  = document.getElementById("authEmail");
const authPassword = document.getElementById("authPassword");
const authLogin  = document.getElementById("authLogin");
const authSignup = document.getElementById("authSignup");
const authForgot = document.getElementById("authForgot");
const authMsg    = document.getElementById("authMsg");

const authRecovery = document.getElementById("authRecovery");
const authNewPassword = document.getElementById("authNewPassword");
const authNewPassword2 = document.getElementById("authNewPassword2");
const authSetNewPassword = document.getElementById("authSetNewPassword");
const authDangerZone = document.getElementById("authDangerZone");
const authDelete = document.getElementById("authDelete");
/* ====== MODAL helpers ====== */
function openAuthModal() {
  authMsg.textContent = "";
  try { if (typeof enableRecoveryUI === "function") enableRecoveryUI(false); } catch(e) {}
  authModal.classList.add("open");
  authModal.setAttribute("aria-hidden", "false");
  setTimeout(() => authEmail.focus(), 50);
}
function closeAuthModal() {
  authModal.classList.remove("open");
  authModal.setAttribute("aria-hidden", "true");
}
authModal.addEventListener("click", (e) => { if (e.target === authModal) closeAuthModal(); });
authClose.addEventListener("click", closeAuthModal);
btnLogin.addEventListener("click", openAuthModal);
if(btnUpgrade) btnUpgrade.addEventListener("click", ()=>startStripeCheckout());

/* ====== Session state ====== */
async function setAuthUI(session) {
  if (session?.user) {
    authPill.classList.remove("no");
    authPill.classList.add("ok");

    // Vis Pro/Gratis i UI
    let ent = null;
    try { ent = await fetchEntitlements(true); } catch(e) {}
    const proLabel = (ent && ent.is_pro) ? "PRO" : "Gratis";
    authPill.textContent = `üîê ${session.user.email} ‚Ä¢ ${proLabel}`;
    // Vis oppgrader-knapp n√•r innlogget men ikke Pro
    try{
      if(btnUpgrade){ btnUpgrade.style.display = (ent && ent.is_pro) ? "none" : ""; }
    }catch(e){}

    // Vis innstillinger / fare-sone n√•r innlogget
    try { if (authDangerZone) authDangerZone.style.display = ""; } catch(e) {}

    btnLogin.style.display = "none";
    btnLogout.style.display = "";
  } else {
    authPill.classList.remove("ok");
    authPill.classList.add("no");
    authPill.textContent = "üîì Demo (ikke innlogget)";
    try { if (authDangerZone) authDangerZone.style.display = "none"; } catch(e) {}
    btnLogin.style.display = "";
    try{ if(btnUpgrade) btnUpgrade.style.display = "none"; }catch(e){}
    btnLogout.style.display = "none";
  }
}

/* Hent initial session */
(async () => {
  const { data } = await supabaseClient.auth.getSession();
  await setAuthUI(data?.session);
if (pendingAction && data?.session?.user) {
    const fn = pendingAction; pendingAction = null;
    try { await fn(); } catch (e) { console.error(e); }
  }
})();

/* Lytt p√• endringer */
supabaseClient.auth.onAuthStateChange(async (_event, session) => {
  await setAuthUI(session);

  // Passord-gjenoppretting: Supabase sender brukeren tilbake hit med recovery-event
  if (_event === "PASSWORD_RECOVERY") {
    inRecoveryFlow = true;
    pendingAction = null;
    try { openAuthModal(); } catch (e) {}
    try {
      if (typeof enableRecoveryUI === "function") enableRecoveryUI(true);
    } catch (e) {}
    return;
  }
  if (session?.user && !inRecoveryFlow) closeAuthModal();
if (pendingAction && session?.user) {
    const fn = pendingAction; pendingAction = null;
    try { await fn(); } catch (e) { console.error(e); }
  }
});

btnLogout.addEventListener("click", async () => {
  await supabaseClient.auth.signOut();
});

/* ====== Passord-innlogging ====== */
function enableRecoveryUI(on){
  if(!authRecovery) return;
  authRecovery.style.display = on ? "block" : "none";
  // N√•r vi er i recovery, brukes "new password"-feltene i stedet for vanlig innlogging
  try {
    if(on){
      authMsg.textContent = "Skriv inn nytt passord for kontoen din.";
      if(authNewPassword) authNewPassword.value = "";
      if(authNewPassword2) authNewPassword2.value = "";
      setTimeout(()=>{ try{ authNewPassword && authNewPassword.focus(); }catch(e){} }, 50);
    }
  } catch(e){}
}

function setAuthBusy(b){
  try{
    if(authLogin) authLogin.disabled = b;
    if(authSignup) authSignup.disabled = b;
    if(authForgot) authForgot.disabled = b;
    if(authSetNewPassword) authSetNewPassword.disabled = b;
  }catch(e){}
}

authLogin && authLogin.addEventListener("click", async () => {
  const email = (authEmail.value || "").trim();
  const password = (authPassword.value || "");
  if (!email || !password) { authMsg.textContent = "Skriv inn e-post og passord."; return; }

  setAuthBusy(true);
  authMsg.textContent = "Logger inn‚Ä¶";
  try {
    const { error } = await withTimeout(supabaseClient.auth.signInWithPassword({ email, password }), 15000);
    if (error) throw error;
    authMsg.textContent = "‚úÖ Innlogget.";
  } catch (err) {
    console.error(err);
    authMsg.textContent = (err?.message==="timeout") ? "‚ùå Innlogging tok for lang tid (nett/cache). Pr√∏v hard refresh eller privat vindu." : "‚ùå Kunne ikke logge inn. Sjekk e-post/passord.";
  } finally {
    setAuthBusy(false);
  }
});

authSignup && authSignup.addEventListener("click", async () => {
  const email = (authEmail.value || "").trim();
  const password = (authPassword.value || "");
  if (!email || !password) { authMsg.textContent = "Skriv inn e-post og passord."; return; }
  if (password.length < 8) { authMsg.textContent = "Passord m√• v√¶re minst 8 tegn."; return; }

  setAuthBusy(true);
  authMsg.textContent = "Oppretter konto‚Ä¶";
  try {
    const { data, error } = await withTimeout(supabaseClient.auth.signUp({
      email,
      password,
      options: { emailRedirectTo: APP_BASE_URL }
    }), 15000);
    if (error) throw error;

    // Supabase kan v√¶re satt opp til √• kreve e-postbekreftelse f√∏r innlogging.
    // Da f√•r du typisk `data.session === null`.
    if (data && data.session) {
      authMsg.textContent = "‚úÖ Konto opprettet og innlogget.";
    } else {
      authMsg.textContent = "‚úÖ Konto opprettet. Vi har sendt deg en bekreftelsesmail (confirmation). √Öpne e-posten og bekreft kontoen ‚Äì deretter kan du logge inn.";
    }
  } catch (err) {
    console.error(err);
    authMsg.textContent = (err?.message==="timeout") ? "‚ùå Oppretting tok for lang tid (nett/cache). Pr√∏v igjen eller privat vindu." : "‚ùå Kunne ikke opprette konto. Pr√∏v et annet passord eller sjekk e-post.";
  } finally {
    setAuthBusy(false);
  }
});

authForgot && authForgot.addEventListener("click", async () => {
  const email = (authEmail.value || "").trim();
  if (!email) { authMsg.textContent = "Skriv inn e-post f√∏rst."; return; }

  setAuthBusy(true);
  authMsg.textContent = "Sender passordlenke‚Ä¶";
  try {
    const { error } = await withTimeout(supabaseClient.auth.resetPasswordForEmail(email, {
      redirectTo: APP_BASE_URL
    }), 15000);
    if (error) throw error;
    authMsg.textContent = "‚úÖ Sjekk e-posten din for lenke til √• sette nytt passord.";
  } catch (err) {
    console.error(err);
    authMsg.textContent = (err?.message==="timeout") ? "‚ùå Foresp√∏rselen tok for lang tid. Pr√∏v igjen." : "‚ùå Kunne ikke sende passordlenke. Sjekk e-postadresse.";
  } finally {
    setAuthBusy(false);
  }
});

authSetNewPassword && authSetNewPassword.addEventListener("click", async () => {
  const p1 = (authNewPassword.value || "");
  const p2 = (authNewPassword2.value || "");
  if (!p1 || !p2) { authMsg.textContent = "Skriv inn nytt passord to ganger."; return; }
  if (p1 !== p2) { authMsg.textContent = "Passordene er ikke like."; return; }

  // M√• ha gyldig session fra recovery-lenken
  const { data: sessData } = await supabaseClient.auth.getSession();
  if(!sessData?.session){
    authMsg.textContent = "‚ùå Ugyldig/utl√∏pt passordlenke. Trykk ¬´Glemt passord¬ª og be om ny lenke.";
    return;
  }
  if (p1.length < 8) { authMsg.textContent = "Passord m√• v√¶re minst 8 tegn."; return; }

  setAuthBusy(true);
  authMsg.textContent = "Oppdaterer passord‚Ä¶";
  try {
    const { error } = await withTimeout(supabaseClient.auth.updateUser({ password: p1 }), 15000);
    if (error) throw error;
    authMsg.textContent = "‚úÖ Passord oppdatert. Du er n√• innlogget.";
    enableRecoveryUI(false);
    inRecoveryFlow = false;
    try{ history.replaceState(null, "", window.location.pathname + window.location.search); }catch(e){}
    // Lukk modal etter kort tid
    setTimeout(()=>{ try{ closeAuthModal(); }catch(e){} }, 600);
  } catch (err) {
    console.error(err);
    authMsg.textContent = (err?.message==="timeout") ? "‚ùå Passordbytte tok for lang tid. Pr√∏v ny lenke via ¬´Glemt passord¬ª." : "‚ùå Kunne ikke oppdatere passord. Pr√∏v igjen.";
  } finally {
    setAuthBusy(false);
  }
});


// ====== Delete account ======
async function deleteMyAccount(){
  if(!sb){ toast("Supabase ikke tilgjengelig."); return; }
  const { data: sess } = await sb.auth.getSession();
  const token = sess?.session?.access_token;
  if(!token){ toast("Du m√• v√¶re innlogget."); return; }

  const confirmText = prompt("Dette sletter kontoen og kan ikke angres. Skriv SLETT for √• bekrefte:");
  if(confirmText !== "SLETT"){ toast("Avbrutt."); return; }

  try{
    if(authDelete) authDelete.disabled = true;
    const res = await fetch(`${API_BASE}/api/delete_account`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`
      },
      body: JSON.stringify({})
    });
    if(!res.ok){
      const msg = await res.text().catch(()=> "");
      toast(`Kunne ikke slette konto (${res.status}). ${msg ? msg.slice(0,120) : ""}`);
      return;
    }
    toast("Konto slettet. Du er n√• logget ut.");
    try{ await sb.auth.signOut(); }catch(e){}
    try{ localStorage.removeItem("skriveflyt_pro_cache"); }catch(e){}
    try{ closeAuthModal(); }catch(e){}
    try{ await updateAuthUI(); }catch(e){}
  } finally {
    if(authDelete) authDelete.disabled = false;
  }
}
if(authDelete){
  authDelete.addEventListener("click", deleteMyAccount);
}

/* ====== Soft-gate wrappers ====== */
async function requireLogin(actionFn) {
  const { data } = await supabaseClient.auth.getSession();
  if (data?.session?.user) return actionFn();
  pendingAction = actionFn;
  openAuthModal();
}

async function getAccessToken() {
  const { data } = await supabaseClient.auth.getSession();
  return data?.session?.access_token || null;
}

/* Fetch-wrapper: legger p√• Authorization-header automatisk */
async function apiFetch(url, options = {}) {
  const token = await getAccessToken();
  const headers = new Headers(options.headers || {});
  if (token) headers.set("Authorization", "Bearer " + token);
  return fetch(url, { ...options, headers });
}
    let cachedEntitlements = null;
let entitlementsFetchedAt = 0;
const ENTITLEMENTS_TTL_MS = 60 * 1000; // 1 min cache

async function fetchEntitlements(force = false) {
  const now = Date.now();
  if (!force && cachedEntitlements && (now - entitlementsFetchedAt) < ENTITLEMENTS_TTL_MS) {
    return cachedEntitlements;
  }

  const { data: sessionData } = await supabaseClient.auth.getSession();
  const session = sessionData?.session;
  if (!session?.user?.id) {
    cachedEntitlements = null;
    entitlementsFetchedAt = now;
    return null;
  }

  // hent profil
  const { data, error } = await supabaseClient
    .from("profiles")
    .select("role,is_pro")
    .eq("id", session.user.id)
    .single();

  if (error) {
    console.warn("Kunne ikke hente entitlements:", error);
    cachedEntitlements = { role: "free", is_pro: false };
  } else {
    cachedEntitlements = {
      role: data?.role || "free",
      is_pro: !!data?.is_pro
    };
  }

  entitlementsFetchedAt = now;
  return cachedEntitlements;
}

async function startStripeCheckout(){
  try{
    const r = await apiFetchAuthed('/api/stripe/create_checkout_session', { method: 'POST' });
    const data = await r.json();
    if(!r.ok) throw new Error(data?.detail || 'Kunne ikke starte betaling');
    if(!data?.url) throw new Error('Mangler checkout-url');
    window.location.href = data.url;
  }catch(e){
    alert('Betaling feilet: ' + (e?.message || e));
  }
}

function showUpgradeModal(reasonText = "") {
  const msg = `üîí Krever Pro-tilgang.\n${reasonText || "Oppgrader for √• bruke denne funksjonen."}\n\nVil du oppgradere n√•?`;
  if(confirm(msg)) startStripeCheckout();
}

async function requirePro(action, reason = "") {
  await softGate.requireLogin(async () => {
    const ent = await fetchEntitlements(true);
    if (ent?.is_pro) return action();
    showUpgradeModal(reason);
  });
}


/* Eksporter til global scope s√• du kan bruke det i eksisterende kode */
window.softGate = { requireLogin, apiFetch, getAccessToken };
</script>

    <!-- Template Editor Modal -->
    <div id="templateEditorModal" class="modal-overlay" style="display:none;">
      <div class="modal-content template-modal">
        <div class="modal-header">
          <h2 style="margin:0;">Malbank</h2>
          <button class="modal-close" onclick="closeTemplateEditor()" aria-label="Lukk">√ó</button>
        </div>

        <div class="template-toolbar">
          <input type="text" id="tplSearch" placeholder="S√∏k i maler..." oninput="renderTemplateList()" />
          <button type="button" onclick="newTemplate()">+ Ny mal</button>
          <button type="button" onclick="exportTemplates()">Eksporter</button>
          <button type="button" onclick="document.getElementById('tplImportFile').click()">Importer</button>
          <input type="file" id="tplImportFile" accept="application/json" style="display:none;" onchange="importTemplates(event)" />
        </div>

        <div class="template-body">
          <div class="template-list">
            <div id="tplList"></div>
          </div>

          <div class="template-editor">
            <label for="tplTitle"><strong>Tittel</strong></label>
            <input type="text" id="tplTitle" placeholder="F.eks. Blodpr√∏ver rekvirert" />

            <label for="tplKeywords" style="margin-top:10px;"><strong>N√∏kkelord (valgfritt)</strong></label>
            <input type="text" id="tplKeywords" placeholder="kommaseparert, f.eks. diabetes, HbA1c, kontroll" />

            <label for="tplContent" style="margin-top:10px;"><strong>Innhold</strong></label>
            <textarea id="tplContent" rows="12" placeholder="Skriv inn malen her..."></textarea>

            <div class="template-editor-actions">
              <button type="button" onclick="saveTemplateFromEditor()">Lagre</button>
              <button type="button" class="danger" onclick="deleteCurrentTemplate()">Slett</button>
              <span id="tplStatus" style="margin-left:auto; font-size:12px; color:#444;"></span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Save-as-template Modal -->
    <div id="saveAsTemplateModal" class="modal-overlay" style="display:none;">
      <div class="modal-content template-modal" style="max-width:720px;">
        <div class="modal-header">
          <h2 style="margin:0;">üíæ Lagre som mal</h2>
          <button class="modal-close" onclick="closeSaveAsTemplateModal()" aria-label="Lukk">√ó</button>
        </div>

        <div class="template-editor" style="padding-top:8px;">
          <label for="satTitle"><strong>Tittel</strong></label>
          <input type="text" id="satTitle" placeholder="Gi malen en tittel" />

          <label for="satKeywords" style="margin-top:10px;"><strong>N√∏kkelord (valgfritt)</strong></label>
          <input type="text" id="satKeywords" placeholder="kommaseparert, f.eks. UVI, antibiotika, oppf√∏lging" />

          <label for="satContent" style="margin-top:10px;"><strong>Innhold</strong></label>
          <textarea id="satContent" rows="10"></textarea>

          <div class="template-editor-actions">
            <button type="button" onclick="confirmSaveAsTemplate()">Lagre</button>
            <button type="button" class="secondary" onclick="closeSaveAsTemplateModal()">Avbryt</button>
            <span id="satStatus" style="margin-left:auto; font-size:12px; color:#444;"></span>
          </div>
        </div>
      </div>
    </div>



<div id="helpModal" class="modal-overlay" style="display:none;" aria-hidden="true">
  <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
    <div class="modal-header">
      <h3 id="helpModalTitle">üìö Brukerveiledning</h3>
      <button type="button" class="modal-close" id="btnHelpClose" aria-label="Lukk">√ó</button>
    </div>

    <!-- ‚úÖ INNHOLDET DITT SKAL LIGGE HER (kun dette omr√•det byttes) -->
    <div style="max-height:70vh; overflow:auto; padding:4px 2px 2px 2px; line-height:1.5;">

  <p style="margin-top:0;">
    Denne veiledningen handler om trygg og effektiv bruk av verkt√∏yet for tekstutkast.
    Verkt√∏yet er ikke et arkiv- eller saksbehandlingssystem.
  </p>

  <h4 style="margin:16px 0 6px 0;">1) Grunnflyt (anbefalt arbeidsm√•te)</h4>
  <ol style="margin:0 0 10px 18px;">
    <li>Start med diktat eller skriving i tekstfeltet.</li>
    <li>Teksten fors√∏kes automatisk anonymisert f√∏r den sendes. Funksjonen kan justeres i innstillinger</li>
    <li>Velg riktig prompt og trykk ¬´Send til GPT¬ª.</li>
    <li>Bruk resultatet som utkast og kvalitetssikre alltid f√∏r bruk.</li>
  </ol>

  <h4 style="margin:16px 0 6px 0;">2) Diktat og Push-to-talk (PTT)</h4>
  <ul style="margin:0 0 10px 18px;">
    <li><strong>Push-to-talk:</strong> Hold inne knappen for opptak, slipp for √• sende til transkribering.</li>
    <li><strong>Korte fraser:</strong> Fungerer best med korte opptak (1‚Äì3 sekunder).</li>
    <li>Ved lengre diktat: Snakk rolig og naturlig, og del gjerne opp i setninger.</li>
    <li>Hvis noe blir feil transkribert: Korriger i tekstfeltet og send p√• nytt.</li>
  </ul>

  <h4 style="margin:16px 0 6px 0;">3) Prompter og maler ‚Äì hva er forskjellen?</h4>
  <ul style="margin:0 0 10px 18px;">
    <li><strong>Prompt-maler (i Prompt Editor):</strong> Instruksjoner som styrer hvordan GPT skal svare.</li>
    <li><strong>Maler (malbank):</strong> Tekststrukturer og faste formuleringer du vil kunne gjenbruke.</li>
    <li>De kan kombineres: En prompt gir instruksjon, mens malen gir struktur.</li>
  </ul>

<h4 style="margin:16px 0 6px 0;">3) Prompter og maler ‚Äì hvordan brukes de sammen?</h4>
<ul style="margin:0 0 10px 18px;">
  <li><strong>Prompten</strong> styrer hva GPT skal gj√∏re (oppgave, struktur, stil, niv√•).</li>
  <li><strong>Maler (malbank)</strong> er tidligere tekster/strukturer som kan legges ved som kontekst.</li>
  <li>N√•r du huker av for <strong>¬´Legg ved maler¬ª</strong>, velger programmet automatisk
      opptil <strong>5 relevante maler</strong> basert p√• innholdet.</li>
  <li>De valgte malene sendes sammen med prompten som <em>grunnlag</em> for GPT.</li>
</ul>

<h4 style="margin:16px 0 6px 0;">4) Hvordan styre bruken av vedlagte maler i prompten</h4>
<p style="margin:0 0 8px 0;">
  I selve prompt-teksten kan du beskrive <strong>hvordan GPT skal bruke de vedlagte malene</strong>.
  Dette gir bedre og mer forutsigbare svar.
</p>

<ul style="margin:0 0 10px 18px;">
  <li>Du kan be GPT bruke malene som <strong>inspirasjon</strong>.</li>
  <li>Du kan be GPT bruke dem til <strong>utfylling eller struktur</strong>.</li>
  <li>Du kan be GPT etterligne <strong>spr√•k, stil eller niv√•</strong> fra malene.</li>
</ul>

<div style="background:#f9fafb; border:1px solid #e5e7eb; border-radius:10px; padding:10px; font-size:13px;">
  <strong>Eksempler p√• formulering i prompt:</strong><br><br>

  ‚Ä¢ ¬´Bruk vedlagte maler som inspirasjon til struktur og formulering.¬ª<br>
  ‚Ä¢ ¬´Fyll ut teksten basert p√• vedlagte maler der det er relevant.¬ª<br>
  ‚Ä¢ ¬´Bruk spr√•k og stil fra vedlagte maler, men tilpass innholdet til teksten over.¬ª
</div>


  <h4 style="margin:16px 0 6px 0;">5) Lagring ‚Äì alt lagres lokalt</h4>
  <ul style="margin:0 0 10px 18px;">
    <li>Prompter og malbank lagres i <strong>localStorage</strong> i nettleseren.</li>
    <li>Innholdet blir normalt v√¶rende selv om du lukker nettleseren.</li>
    <li>Kan forsvinne ved sletting av nettleserdata, inkognito eller bytte av profil.</li>
    <li>LocalStorage synkroniseres ikke automatisk mellom PC-er.</li>
  </ul>

  <h4 style="margin:16px 0 6px 0;">6) Unng√• √• miste innhold (backup)</h4>
  <ul style="margin:0 0 10px 18px;">
    <li>Bruk <strong>Eksporter</strong> jevnlig i prompt-editor og malbank.</li>
    <li>Lagre eksportfilen p√• et trygt sted.</li>
    <li>Ved ny PC/nettleser: Bruk <strong>Importer</strong>.</li>
    <li>Ta alltid eksport f√∏r st√∏rre endringer.</li>
  </ul>

  <h4 style="margin:16px 0 6px 0;">7) Import / eksport ‚Äì praktiske tips</h4>
  <ul style="margin:0 0 10px 18px;">
    <li>Eksporter f√∏r oppdateringer eller opprydding.</li>
    <li>Bruk filnavn med dato (f.eks. <code>prompter_2025-12-24.json</code>).</li>
    <li>Importer ved tap av innhold eller flytting til ny maskin.</li>
  </ul>

  <h4 style="margin:16px 0 6px 0;">8) Anonymisering (viktig)</h4>
  <ul style="margin:0 0 10px 18px;">
    <li>Anonymisering er en <strong>hjelp</strong>, ikke en garanti.</li>
    <li>Utf√∏res lokalt i nettleseren f√∏r sending.</li>
    <li>Kan overse navn, steder eller kontekstuell identifiserbarhet.</li>
    <li>Manuell kontroll er alltid n√∏dvendig.</li>
  </ul>

  <h4 style="margin:16px 0 6px 0;">9) Kvalitetssikring av GPT-svar</h4>
  <ul style="margin:0 0 10px 18px;">
    <li>GPT kan anta eller formulere feil informasjon.</li>
    <li>Sjekk s√¶rlig fakta, tall, navn, datoer og p√•stander.</li>
    <li>Bruk GPT som utkast ‚Äì du er redakt√∏r.</li>
  </ul>

  <hr style="border:none; border-top:1px solid #eee; margin:16px 0;">

  <p style="margin:0;">
    <strong>Husk:</strong> Ikke legg inn identifiserende personopplysninger eller annet konfidensielt innhold.
    Du er selv ansvarlig for korrekt og regelverksmessig bruk.
  </p>

</div>
</div>
    </div>

  </div>
</div>


<!-- =========================
     Anonymisering ‚Äì Innstillinger (Modal)
     ========================= -->
<div class="pe-modal" id="privacySettingsModal" style="display:none;">
  <div class="pe-card" style="width:min(900px,96vw); height:min(720px,94vh);">
    <div class="pe-header" style="display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid #e6e6e6;">
      <div>
        <div style="font-weight:700; font-size:16px;">üîí Anonymisering ‚Äì innstillinger</div>
        <div style="font-size:12px; color:#666; margin-top:2px;">Styrer automatisk anonymisering ved ¬´Send til GPT¬ª + valg av modus.</div>
      </div>
      <button type="button" class="pe-close" onclick="closePrivacySettingsModal()" style="border:1px solid #ddd; background:#fff; border-radius:10px; padding:8px 10px; cursor:pointer;">‚úï</button>
    </div>

    <div style="padding:16px; overflow:auto;">
      <div style="display:flex; gap:14px; flex-wrap:wrap; align-items:flex-start;">
        <div style="flex:1; min-width:320px; border:1px solid #eee; border-radius:12px; padding:12px;">
          <div style="font-weight:700; margin-bottom:10px;">Automatikk</div>

          <label style="display:flex; gap:10px; align-items:center; cursor:pointer; user-select:none;">
            <input type="checkbox" id="chkAutoAnonymize" />
            <span><strong>Auto-anonymiser</strong> ved ¬´Send til GPT¬ª</span>
          </label>

          <div style="margin-top:12px;">
            <label for="selAnonymMode" style="display:block; font-size:12px; color:#555; margin-bottom:6px;">Anonymiseringsmodus</label>
            <select id="selAnonymMode" style="width:100%; padding:10px; border-radius:10px; border:1px solid #ddd;">
              <option value="mild">Mild (lavere risiko for falske positive)</option>
              <option value="hybrid">Hybrid (strengere, mer treff ‚Äì med filter mot falske navn)</option>
              <option value="strict">Streng (mest maskering ‚Äì kan gi flere falske positive)</option>
            </select>
            <div style="font-size:12px; color:#666; margin-top:8px; line-height:1.35;">
              * ¬´Hybrid¬ª kombinerer faste m√∏nstre (FNR, tlf, epost, ID, IP, kontonr osv.) med smartere navn-/adresse-regler + stoppliste.
            </div>
          </div>

          <div style="display:flex; gap:10px; margin-top:14px; flex-wrap:wrap;">
            <button type="button" onclick="runAnonymizePreview()" style="border:1px solid #ddd; background:#fff; border-radius:10px; padding:10px 12px; cursor:pointer;">Forh√•ndsvis anonymisering</button>
            <button type="button" onclick="anonymiserTekst(true)" style="border:1px solid #ddd; background:#fff; border-radius:10px; padding:10px 12px; cursor:pointer;">Anonymiser n√•</button>
          </div>
        </div>

        <div style="flex:1; min-width:320px; border:1px solid #eee; border-radius:12px; padding:12px;">
          <div style="font-weight:700; margin-bottom:10px;">Sist anonymisert</div>
          <div style="font-size:12px; color:#666; margin-bottom:10px;">
            Viser hva som ble maskert ved forrige anonymisering (manuell eller automatisk).
          </div>

          <div id="lastAnonymizedSummary" style="font-size:12px; color:#444; margin-bottom:10px;"></div>

          <div style="max-height:360px; overflow:auto; border:1px solid #f0f0f0; border-radius:10px; padding:10px;">
            <ul id="lastAnonymizedList" style="margin:0; padding-left:18px;"></ul>
          </div>

          <div style="display:flex; gap:10px; margin-top:14px; flex-wrap:wrap;">
            <button type="button" onclick="clearLastAnonymized()" style="border:1px solid #ddd; background:#fff; border-radius:10px; padding:10px 12px; cursor:pointer;">T√∏m liste</button>
          </div>
        </div>
      </div>

      <div style="margin-top:14px; border:1px dashed #e2e2e2; border-radius:12px; padding:12px;">
        <div style="font-weight:700; margin-bottom:6px;">Tips</div>
        <div style="font-size:12px; color:#555; line-height:1.45;">
          ‚Ä¢ Hvis du f√•r falske positive navn (f.eks. ¬´Ole bekrefter ‚Ä¶¬ª) ‚Üí bruk ¬´Mild¬ª eller ¬´Hybrid¬ª.<br>
          ‚Ä¢ Hvis du ser at noen navn/adresser glipper (sm√• bokstaver, flere varianter) ‚Üí bruk ¬´Hybrid¬ª eller ¬´Streng¬ª.<br>
          ‚Ä¢ Husk: ingen automatikk kan garantere 100% avidentifisering.
        </div>
      </div>

      <div id="privacyPreviewBox" style="display:none; margin-top:14px; border:1px solid #eee; border-radius:12px; padding:12px;">
        <div style="font-weight:700; margin-bottom:8px;">Forh√•ndsvisning</div>
        <textarea id="privacyPreviewText" style="width:100%; min-height:140px; padding:10px; border-radius:10px; border:1px solid #ddd;"></textarea>
      </div>
    </div>
  </div>
</div>


<button type="button" id="authResetBtn" onclick="hardResetAuth()"
style="position:fixed;bottom:12px;right:12px;z-index:9999;opacity:.6">
  Nullstill innlogging
</button>
</body>

</html>
